__BRYTHON__.use_VFS = true
__BRYTHON__.VFS = {"browser.highlight": [".py", "import keyword\nimport _jsre as re\n\nfrom browser import html\n\nletters='abcdefghijklmnopqrstuvwxyz'\nletters +=letters. upper()+'_'\ndigits='0123456789'\n\nbuiltin_funcs=\"\"\"abs|dict|help|min|setattr|\nall|dir|hex|next|slice|\nany|divmod|id|object|sorted|\nascii|enumerate|input|oct|staticmethod|\nbin|eval|int|open|str|\nbool|exec|isinstance|ord|sum|\nbytearray|filter|issubclass|pow|super|\nbytes|float|iter|print|tuple|\ncallable|format|len|property|type|\nchr|frozenset|list|range|vars|\nclassmethod|getattr|locals|repr|zip|\ncompile|globals|map|reversed|__import__|\ncomplex|hasattr|max|round|\ndelattr|hash|memoryview|set|\n\"\"\"\n\nkw_pattern='^('+'|'. join(keyword. kwlist)+')$'\nbf_pattern='^('+builtin_funcs. replace(\"\\n\",\"\")+')$'\n\ndef escape(txt):\n txt=txt. replace('<','&lt;')\n txt=txt. replace('>','&gt;')\n return txt\n \ndef highlight(txt,string_color=\"blue\",comment_color=\"green\",\nkeyword_color=\"purple\",builtin_func_color=\"#963\"):\n res=html. PRE()\n i=0\n name=''\n while i <len(txt):\n  car=txt[i]\n  if car in [\"'\",'\"']:\n   found_match=False\n   k=i+1\n   while k <len(txt):\n    if txt[k]==car:\n     nb_as=0\n     j=k -1\n     while True :\n      if txt[j]=='\\\\':\n       nb_as +=1\n       j -=1\n      else :\n       break\n     if nb_as %2 ==0:\n      res <=name+html. SPAN(escape(txt[i:k+1]),\n      Class=\"python-string\")\n      i=k\n      name=''\n      found_match=True\n      break\n    k +=1\n   if not found_match:\n    name +=car\n  elif car =='#':\n   end=txt. find('\\n',i)\n   if end ==-1:\n    res <=html. SPAN(escape(txt[i:]),Class=\"python-comment\")\n    break\n   else :\n    res <=html. SPAN(escape(txt[i:end]),Class=\"python-comment\")\n    i=end -1\n  elif car in letters:\n   name +=car\n  elif car in digits and name:\n   name +=car\n  else :\n   if name:\n    if re. search(kw_pattern,name):\n     res <=html. SPAN(name,Class=\"python-keyword\")\n    elif re. search(bf_pattern,name):\n     res <=html. SPAN(name,Class=\"python-builtin\")\n    else :\n     res <=name\n    name=''\n   res <=car\n  i +=1\n res <=name\n return res"], "sre_constants": [".py", "\n\n\n\n\n\n\n\n\n\n\n\"\"\"Internal support module for sre\"\"\"\n\n\n\nMAGIC=20031017\n\n\n\n\n\n\n\nclass error(Exception):\n pass\n \n \n \nFAILURE=\"failure\"\nSUCCESS=\"success\"\n\nANY=\"any\"\nANY_ALL=\"any_all\"\nASSERT=\"assert\"\nASSERT_NOT=\"assert_not\"\nAT=\"at\"\nBIGCHARSET=\"bigcharset\"\nBRANCH=\"branch\"\nCALL=\"call\"\nCATEGORY=\"category\"\nCHARSET=\"charset\"\nGROUPREF=\"groupref\"\nGROUPREF_IGNORE=\"groupref_ignore\"\nGROUPREF_EXISTS=\"groupref_exists\"\nIN=\"in\"\nIN_IGNORE=\"in_ignore\"\nINFO=\"info\"\nJUMP=\"jump\"\nLITERAL=\"literal\"\nLITERAL_IGNORE=\"literal_ignore\"\nMARK=\"mark\"\nMAX_REPEAT=\"max_repeat\"\nMAX_UNTIL=\"max_until\"\nMIN_REPEAT=\"min_repeat\"\nMIN_UNTIL=\"min_until\"\nNEGATE=\"negate\"\nNOT_LITERAL=\"not_literal\"\nNOT_LITERAL_IGNORE=\"not_literal_ignore\"\nRANGE=\"range\"\nREPEAT=\"repeat\"\nREPEAT_ONE=\"repeat_one\"\nSUBPATTERN=\"subpattern\"\nMIN_REPEAT_ONE=\"min_repeat_one\"\n\n\nAT_BEGINNING=\"at_beginning\"\nAT_BEGINNING_LINE=\"at_beginning_line\"\nAT_BEGINNING_STRING=\"at_beginning_string\"\nAT_BOUNDARY=\"at_boundary\"\nAT_NON_BOUNDARY=\"at_non_boundary\"\nAT_END=\"at_end\"\nAT_END_LINE=\"at_end_line\"\nAT_END_STRING=\"at_end_string\"\nAT_LOC_BOUNDARY=\"at_loc_boundary\"\nAT_LOC_NON_BOUNDARY=\"at_loc_non_boundary\"\nAT_UNI_BOUNDARY=\"at_uni_boundary\"\nAT_UNI_NON_BOUNDARY=\"at_uni_non_boundary\"\n\n\nCATEGORY_DIGIT=\"category_digit\"\nCATEGORY_NOT_DIGIT=\"category_not_digit\"\nCATEGORY_SPACE=\"category_space\"\nCATEGORY_NOT_SPACE=\"category_not_space\"\nCATEGORY_WORD=\"category_word\"\nCATEGORY_NOT_WORD=\"category_not_word\"\nCATEGORY_LINEBREAK=\"category_linebreak\"\nCATEGORY_NOT_LINEBREAK=\"category_not_linebreak\"\nCATEGORY_LOC_WORD=\"category_loc_word\"\nCATEGORY_LOC_NOT_WORD=\"category_loc_not_word\"\nCATEGORY_UNI_DIGIT=\"category_uni_digit\"\nCATEGORY_UNI_NOT_DIGIT=\"category_uni_not_digit\"\nCATEGORY_UNI_SPACE=\"category_uni_space\"\nCATEGORY_UNI_NOT_SPACE=\"category_uni_not_space\"\nCATEGORY_UNI_WORD=\"category_uni_word\"\nCATEGORY_UNI_NOT_WORD=\"category_uni_not_word\"\nCATEGORY_UNI_LINEBREAK=\"category_uni_linebreak\"\nCATEGORY_UNI_NOT_LINEBREAK=\"category_uni_not_linebreak\"\n\nOPCODES=[\n\n\nFAILURE,SUCCESS,\n\nANY,ANY_ALL,\nASSERT,ASSERT_NOT,\nAT,\nBRANCH,\nCALL,\nCATEGORY,\nCHARSET,BIGCHARSET,\nGROUPREF,GROUPREF_EXISTS,GROUPREF_IGNORE,\nIN,IN_IGNORE,\nINFO,\nJUMP,\nLITERAL,LITERAL_IGNORE,\nMARK,\nMAX_UNTIL,\nMIN_UNTIL,\nNOT_LITERAL,NOT_LITERAL_IGNORE,\nNEGATE,\nRANGE,\nREPEAT,\nREPEAT_ONE,\nSUBPATTERN,\nMIN_REPEAT_ONE\n\n]\n\nATCODES=[\nAT_BEGINNING,AT_BEGINNING_LINE,AT_BEGINNING_STRING,AT_BOUNDARY,\nAT_NON_BOUNDARY,AT_END,AT_END_LINE,AT_END_STRING,\nAT_LOC_BOUNDARY,AT_LOC_NON_BOUNDARY,AT_UNI_BOUNDARY,\nAT_UNI_NON_BOUNDARY\n]\n\nCHCODES=[\nCATEGORY_DIGIT,CATEGORY_NOT_DIGIT,CATEGORY_SPACE,\nCATEGORY_NOT_SPACE,CATEGORY_WORD,CATEGORY_NOT_WORD,\nCATEGORY_LINEBREAK,CATEGORY_NOT_LINEBREAK,CATEGORY_LOC_WORD,\nCATEGORY_LOC_NOT_WORD,CATEGORY_UNI_DIGIT,CATEGORY_UNI_NOT_DIGIT,\nCATEGORY_UNI_SPACE,CATEGORY_UNI_NOT_SPACE,CATEGORY_UNI_WORD,\nCATEGORY_UNI_NOT_WORD,CATEGORY_UNI_LINEBREAK,\nCATEGORY_UNI_NOT_LINEBREAK\n]\n\ndef makedict(list):\n d={}\n i=0\n for item in list:\n  d[item]=i\n  i=i+1\n return d\n \nOPCODES=makedict(OPCODES)\nATCODES=makedict(ATCODES)\nCHCODES=makedict(CHCODES)\n\n\nOP_IGNORE={\nGROUPREF:GROUPREF_IGNORE,\nIN:IN_IGNORE,\nLITERAL:LITERAL_IGNORE,\nNOT_LITERAL:NOT_LITERAL_IGNORE\n}\n\nAT_MULTILINE={\nAT_BEGINNING:AT_BEGINNING_LINE,\nAT_END:AT_END_LINE\n}\n\nAT_LOCALE={\nAT_BOUNDARY:AT_LOC_BOUNDARY,\nAT_NON_BOUNDARY:AT_LOC_NON_BOUNDARY\n}\n\nAT_UNICODE={\nAT_BOUNDARY:AT_UNI_BOUNDARY,\nAT_NON_BOUNDARY:AT_UNI_NON_BOUNDARY\n}\n\nCH_LOCALE={\nCATEGORY_DIGIT:CATEGORY_DIGIT,\nCATEGORY_NOT_DIGIT:CATEGORY_NOT_DIGIT,\nCATEGORY_SPACE:CATEGORY_SPACE,\nCATEGORY_NOT_SPACE:CATEGORY_NOT_SPACE,\nCATEGORY_WORD:CATEGORY_LOC_WORD,\nCATEGORY_NOT_WORD:CATEGORY_LOC_NOT_WORD,\nCATEGORY_LINEBREAK:CATEGORY_LINEBREAK,\nCATEGORY_NOT_LINEBREAK:CATEGORY_NOT_LINEBREAK\n}\n\nCH_UNICODE={\nCATEGORY_DIGIT:CATEGORY_UNI_DIGIT,\nCATEGORY_NOT_DIGIT:CATEGORY_UNI_NOT_DIGIT,\nCATEGORY_SPACE:CATEGORY_UNI_SPACE,\nCATEGORY_NOT_SPACE:CATEGORY_UNI_NOT_SPACE,\nCATEGORY_WORD:CATEGORY_UNI_WORD,\nCATEGORY_NOT_WORD:CATEGORY_UNI_NOT_WORD,\nCATEGORY_LINEBREAK:CATEGORY_UNI_LINEBREAK,\nCATEGORY_NOT_LINEBREAK:CATEGORY_UNI_NOT_LINEBREAK\n}\n\n\nSRE_FLAG_TEMPLATE=1\nSRE_FLAG_IGNORECASE=2\nSRE_FLAG_LOCALE=4\nSRE_FLAG_MULTILINE=8\nSRE_FLAG_DOTALL=16\nSRE_FLAG_UNICODE=32\nSRE_FLAG_VERBOSE=64\nSRE_FLAG_DEBUG=128\nSRE_FLAG_ASCII=256\n\n\nSRE_INFO_PREFIX=1\nSRE_INFO_LITERAL=2\nSRE_INFO_CHARSET=4\n\nif __name__ ==\"__main__\":\n def dump(f,d,prefix):\n  items=sorted(d. items(),key=lambda a:a[1])\n  for k,v in items:\n   f. write(\"#define %s_%s %s\\n\"%(prefix,k. upper(),v))\n f=open(\"sre_constants.h\",\"w\")\n f. write(\"\"\"\\\n/*\n * Secret Labs' Regular Expression Engine\n *\n * regular expression matching engine\n *\n * NOTE: This file is generated by sre_constants.py.  If you need\n * to change anything in here, edit sre_constants.py and run it.\n *\n * Copyright (c) 1997-2001 by Secret Labs AB.  All rights reserved.\n *\n * See the _sre.c file for information on usage and redistribution.\n */\n\n\"\"\")\n \n f. write(\"#define SRE_MAGIC %d\\n\"%MAGIC)\n \n dump(f,OPCODES,\"SRE_OP\")\n dump(f,ATCODES,\"SRE\")\n dump(f,CHCODES,\"SRE\")\n \n f. write(\"#define SRE_FLAG_TEMPLATE %d\\n\"%SRE_FLAG_TEMPLATE)\n f. write(\"#define SRE_FLAG_IGNORECASE %d\\n\"%SRE_FLAG_IGNORECASE)\n f. write(\"#define SRE_FLAG_LOCALE %d\\n\"%SRE_FLAG_LOCALE)\n f. write(\"#define SRE_FLAG_MULTILINE %d\\n\"%SRE_FLAG_MULTILINE)\n f. write(\"#define SRE_FLAG_DOTALL %d\\n\"%SRE_FLAG_DOTALL)\n f. write(\"#define SRE_FLAG_UNICODE %d\\n\"%SRE_FLAG_UNICODE)\n f. write(\"#define SRE_FLAG_VERBOSE %d\\n\"%SRE_FLAG_VERBOSE)\n \n f. write(\"#define SRE_INFO_PREFIX %d\\n\"%SRE_INFO_PREFIX)\n f. write(\"#define SRE_INFO_LITERAL %d\\n\"%SRE_INFO_LITERAL)\n f. write(\"#define SRE_INFO_CHARSET %d\\n\"%SRE_INFO_CHARSET)\n \n f. close()\n print(\"done\")\n"], "_sre": [".py", "\n''\n\n\n\n\n\n\n\nMAXREPEAT=2147483648\n\n\nimport operator,sys\nfrom sre_constants import ATCODES,OPCODES,CHCODES\nfrom sre_constants import SRE_INFO_PREFIX,SRE_INFO_LITERAL\nfrom sre_constants import SRE_FLAG_UNICODE,SRE_FLAG_LOCALE\n\n\nimport sys\n\n\n\nMAGIC=20031017\n\n\n\n\n\n\n\n\n\n\n\n\n\nCODESIZE=4\n\ncopyright=\"_sre.py 2.4c Copyright 2005 by Nik Haldimann\"\n\n\ndef getcodesize():\n return CODESIZE\n \ndef compile(pattern,flags,code,groups=0,groupindex={},indexgroup=[None ]):\n ''\n \n return SRE_Pattern(pattern,flags,code,groups,groupindex,indexgroup)\n \ndef getlower(char_ord,flags):\n if (char_ord <128)or (flags&SRE_FLAG_UNICODE) or (flags&SRE_FLAG_LOCALE and char_ord <256):\n \n  return ord(chr(char_ord). lower())\n else :\n  return char_ord\n  \n  \nclass SRE_Pattern:\n\n def __init__(self,pattern,flags,code,groups=0,groupindex={},indexgroup=[None ]):\n  self. pattern=pattern\n  self. flags=flags\n  self. groups=groups\n  self. groupindex=groupindex\n  self. _indexgroup=indexgroup\n  self. _code=code\n  \n def match(self,string,pos=0,endpos=sys. maxsize):\n  ''\n\n  \n  state=_State(string,pos,endpos,self. flags)\n  if state. match(self. _code):\n   return SRE_Match(self,state)\n  return None\n  \n def search(self,string,pos=0,endpos=sys. maxsize):\n  ''\n\n\n  \n  state=_State(string,pos,endpos,self. flags)\n  if state. search(self. _code):\n   return SRE_Match(self,state)\n  else :\n   return None\n   \n def findall(self,string,pos=0,endpos=sys. maxsize):\n  ''\n  matchlist=[]\n  state=_State(string,pos,endpos,self. flags)\n  while state. start <=state. end:\n   state. reset()\n   state. string_position=state. start\n   if not state. search(self. _code):\n    break\n   match=SRE_Match(self,state)\n   if self. groups ==0 or self. groups ==1:\n    item=match. group(self. groups)\n   else :\n    item=match. groups(\"\")\n   matchlist. append(item)\n   if state. string_position ==state. start:\n    state. start +=1\n   else :\n    state. start=state. string_position\n  return matchlist\n  \n def _subx(self,template,string,count=0,subn=False ):\n  filter=template\n  if not callable(template)and\"\\\\\"in template:\n  \n  \n  \n  \n   import re as sre\n   filter=sre. _subx(self,template)\n  state=_State(string,0,sys. maxsize,self. flags)\n  sublist=[]\n  \n  n=last_pos=0\n  while not count or n <count:\n   state. reset()\n   state. string_position=state. start\n   if not state. search(self. _code):\n    break\n   if last_pos <state. start:\n    sublist. append(string[last_pos:state. start])\n   if not (last_pos ==state. start and\n   last_pos ==state. string_position and n >0):\n   \n    if callable(filter):\n     sublist. append(filter(SRE_Match(self,state)))\n    else :\n     sublist. append(filter)\n    last_pos=state. string_position\n    n +=1\n   if state. string_position ==state. start:\n    state. start +=1\n   else :\n    state. start=state. string_position\n    \n  if last_pos <state. end:\n   sublist. append(string[last_pos:state. end])\n  item=\"\". join(sublist)\n  if subn:\n   return item,n\n  else :\n   return item\n   \n def sub(self,repl,string,count=0):\n  ''\n  \n  return self. _subx(repl,string,count,False )\n  \n def subn(self,repl,string,count=0):\n  ''\n\n  \n  return self. _subx(repl,string,count,True )\n  \n def split(self,string,maxsplit=0):\n  ''\n  splitlist=[]\n  state=_State(string,0,sys. maxsize,self. flags)\n  n=0\n  last=state. start\n  while not maxsplit or n <maxsplit:\n   state. reset()\n   state. string_position=state. start\n   if not state. search(self. _code):\n    break\n   if state. start ==state. string_position:\n    if last ==state. end:\n     break\n    state. start +=1\n    continue\n   splitlist. append(string[last:state. start])\n   \n   if self. groups:\n    match=SRE_Match(self,state)\n    splitlist. extend(list(match. groups(None )))\n   n +=1\n   last=state. start=state. string_position\n  splitlist. append(string[last:state. end])\n  return splitlist\n  \n def finditer(self,string,pos=0,endpos=sys. maxsize):\n  ''\n  \n  _list=[]\n  _m=self. scanner(string,pos,endpos)\n  _re=SRE_Scanner(self,string,pos,endpos)\n  _m=_re. search()\n  while _m:\n   _list. append(_m)\n   _m=_re. search()\n  return _list\n  \n  \n def scanner(self,string,start=0,end=sys. maxsize):\n  return SRE_Scanner(self,string,start,end)\n  \n def __copy__(self):\n  raise TypeError(\"cannot copy this pattern object\")\n  \n def __deepcopy__(self):\n  raise TypeError(\"cannot copy this pattern object\")\n  \nclass SRE_Scanner:\n ''\n \n def __init__(self,pattern,string,start,end):\n  self. pattern=pattern\n  self. _state=_State(string,start,end,self. pattern. flags)\n  \n def _match_search(self,matcher):\n  state=self. _state\n  state. reset()\n  state. string_position=state. start\n  match=None\n  if matcher(self. pattern. _code):\n   match=SRE_Match(self. pattern,state)\n  if match is None or state. string_position ==state. start:\n   state. start +=1\n  else :\n   state. start=state. string_position\n  return match\n  \n def match(self):\n  return self. _match_search(self. _state. match)\n  \n def search(self):\n  return self. _match_search(self. _state. search)\n  \nclass SRE_Match:\n\n def __init__(self,pattern,state):\n  self. re=pattern\n  self. string=state. string\n  self. pos=state. pos\n  self. endpos=state. end\n  self. lastindex=state. lastindex\n  if self. lastindex <0:\n   self. lastindex=None\n  self. regs=self. _create_regs(state)\n  \n  \n  \n  if self. lastindex is not None and pattern. _indexgroup and 0 <=self. lastindex <len(pattern. _indexgroup):\n  \n  \n  \n  \n  \n   self. lastgroup=pattern. _indexgroup[self. lastindex]\n  else :\n   self. lastgroup=None\n   \n def _create_regs(self,state):\n  ''\n  regs=[(state. start,state. string_position)]\n  for group in range(self. re. groups):\n   mark_index=2 *group\n   if mark_index+1 <len(state. marks)   and state. marks[mark_index]is not None   and state. marks[mark_index+1]is not None :\n    regs. append((state. marks[mark_index],state. marks[mark_index+1]))\n   else :\n    regs. append((-1,-1))\n  return tuple(regs)\n  \n def _get_index(self,group):\n  if isinstance(group,int):\n   if group >=0 and group <=self. re. groups:\n    return group\n  else :\n   if group in self. re. groupindex:\n    return self. re. groupindex[group]\n  raise IndexError(\"no such group\")\n  \n def _get_slice(self,group,default):\n  group_indices=self. regs[group]\n  if group_indices[0]>=0:\n   return self. string[group_indices[0]:group_indices[1]]\n  else :\n   return default\n   \n def start(self,group=0):\n  ''\n\n  \n  return self. regs[self. _get_index(group)][0]\n  \n def end(self,group=0):\n  ''\n\n  \n  return self. regs[self. _get_index(group)][1]\n  \n def span(self,group=0):\n  ''\n  return self. start(group),self. end(group)\n  \n def expand(self,template):\n  ''\n  \n  import sre\n  return sre. _expand(self. re,self,template)\n  \n def groups(self,default=None ):\n  ''\n\n  \n  groups=[]\n  for indices in self. regs[1:]:\n   if indices[0]>=0:\n    groups. append(self. string[indices[0]:indices[1]])\n   else :\n    groups. append(default)\n  return tuple(groups)\n  \n def groupdict(self,default=None ):\n  ''\n\n  \n  groupdict={}\n  for key,value in self. re. groupindex. items():\n   groupdict[key]=self. _get_slice(value,default)\n  return groupdict\n  \n def group(self,*args):\n  ''\n  \n  if len(args)==0:\n   args=(0,)\n  grouplist=[]\n  for group in args:\n   grouplist. append(self. _get_slice(self. _get_index(group),None ))\n  if len(grouplist)==1:\n   return grouplist[0]\n  else :\n   return tuple(grouplist)\n   \n def __copy__():\n  raise TypeError(\"cannot copy this pattern object\")\n  \n def __deepcopy__():\n  raise TypeError(\"cannot copy this pattern object\")\n  \n  \nclass _State:\n\n def __init__(self,string,start,end,flags):\n  self. string=string\n  if start <0:\n   start=0\n  if end >len(string):\n   end=len(string)\n  self. start=start\n  self. string_position=self. start\n  self. end=end\n  self. pos=start\n  self. flags=flags\n  self. reset()\n  \n def reset(self):\n  self. marks=[]\n  self. lastindex=-1\n  self. marks_stack=[]\n  self. context_stack=[]\n  self. repeat=None\n  \n def match(self,pattern_codes):\n \n \n \n \n \n \n \n \n \n  dispatcher=_OpcodeDispatcher()\n  self. context_stack. append(_MatchContext(self,pattern_codes))\n  has_matched=None\n  while len(self. context_stack)>0:\n   context=self. context_stack[-1]\n   has_matched=dispatcher. match(context)\n   if has_matched is not None :\n    self. context_stack. pop()\n  return has_matched\n  \n def search(self,pattern_codes):\n  flags=0\n  if pattern_codes[0]==OPCODES[\"info\"]:\n  \n  \n   if pattern_codes[2]&SRE_INFO_PREFIX and pattern_codes[5]>1:\n    return self. fast_search(pattern_codes)\n   flags=pattern_codes[2]\n   pattern_codes=pattern_codes[pattern_codes[1]+1:]\n   \n  string_position=self. start\n  if pattern_codes[0]==OPCODES[\"literal\"]:\n  \n  \n   character=pattern_codes[1]\n   while True :\n    while string_position <self. end    and ord(self. string[string_position])!=character:\n     string_position +=1\n    if string_position >=self. end:\n     return False\n    self. start=string_position\n    string_position +=1\n    self. string_position=string_position\n    if flags&SRE_INFO_LITERAL:\n     return True\n    if self. match(pattern_codes[2:]):\n     return True\n   return False\n   \n   \n  while string_position <=self. end:\n   self. reset()\n   self. start=self. string_position=string_position\n   if self. match(pattern_codes):\n    return True\n   string_position +=1\n  return False\n  \n def fast_search(self,pattern_codes):\n  ''\n  \n  \n  \n  flags=pattern_codes[2]\n  prefix_len=pattern_codes[5]\n  prefix_skip=pattern_codes[6]\n  prefix=pattern_codes[7:7+prefix_len]\n  overlap=pattern_codes[7+prefix_len -1:pattern_codes[1]+1]\n  pattern_codes=pattern_codes[pattern_codes[1]+1:]\n  i=0\n  string_position=self. string_position\n  while string_position <self. end:\n   while True :\n    if ord(self. string[string_position])!=prefix[i]:\n     if i ==0:\n      break\n     else :\n      i=overlap[i]\n    else :\n     i +=1\n     if i ==prefix_len:\n     \n      self. start=string_position+1 -prefix_len\n      self. string_position=string_position+1      -prefix_len+prefix_skip\n      if flags&SRE_INFO_LITERAL:\n       return True\n      if self. match(pattern_codes[2 *prefix_skip:]):\n       return True\n      i=overlap[i]\n     break\n   string_position +=1\n  return False\n  \n def set_mark(self,mark_nr,position):\n  if mark_nr&1:\n  \n  \n  \n   self. lastindex=mark_nr //2+1\n  if mark_nr >=len(self. marks):\n   self. marks. extend([None ]*(mark_nr -len(self. marks)+1))\n  self. marks[mark_nr]=position\n  \n def get_marks(self,group_index):\n  marks_index=2 *group_index\n  if len(self. marks)>marks_index+1:\n   return self. marks[marks_index],self. marks[marks_index+1]\n  else :\n   return None ,None\n   \n def marks_push(self):\n  self. marks_stack. append((self. marks[:],self. lastindex))\n  \n def marks_pop(self):\n  self. marks,self. lastindex=self. marks_stack. pop()\n  \n def marks_pop_keep(self):\n  self. marks,self. lastindex=self. marks_stack[-1]\n  \n def marks_pop_discard(self):\n  self. marks_stack. pop()\n  \n def lower(self,char_ord):\n  return getlower(char_ord,self. flags)\n  \n  \nclass _MatchContext:\n\n def __init__(self,state,pattern_codes):\n  self. state=state\n  self. pattern_codes=pattern_codes\n  self. string_position=state. string_position\n  self. code_position=0\n  self. has_matched=None\n  \n def push_new_context(self,pattern_offset):\n  ''\n\n  \n  child_context=_MatchContext(self. state,\n  self. pattern_codes[self. code_position+pattern_offset:])\n  \n  \n  \n  \n  self. state. context_stack. append(child_context)\n  return child_context\n  \n def peek_char(self,peek=0):\n  return self. state. string[self. string_position+peek]\n  \n def skip_char(self,skip_count):\n  self. string_position +=skip_count\n  \n def remaining_chars(self):\n  return self. state. end -self. string_position\n  \n def peek_code(self,peek=0):\n  return self. pattern_codes[self. code_position+peek]\n  \n def skip_code(self,skip_count):\n  self. code_position +=skip_count\n  \n def remaining_codes(self):\n  return len(self. pattern_codes)-self. code_position\n  \n def at_beginning(self):\n  return self. string_position ==0\n  \n def at_end(self):\n  return self. string_position ==self. state. end\n  \n def at_linebreak(self):\n  return not self. at_end()and _is_linebreak(self. peek_char())\n  \n def at_boundary(self,word_checker):\n  if self. at_beginning()and self. at_end():\n   return False\n  that=not self. at_beginning()and word_checker(self. peek_char(-1))\n  this=not self. at_end()and word_checker(self. peek_char())\n  return this !=that\n  \n  \nclass _RepeatContext(_MatchContext):\n\n def __init__(self,context):\n  _MatchContext. __init__(self,context. state,\n  context. pattern_codes[context. code_position:])\n  self. count=-1\n  \n  self. previous=context. state. repeat\n  self. last_position=None\n  \n  \nclass _Dispatcher:\n\n DISPATCH_TABLE=None\n \n def dispatch(self,code,context):\n  method=self. DISPATCH_TABLE. get(code,self. __class__. unknown)\n  return method(self,context)\n  \n def unknown(self,code,ctx):\n  raise NotImplementedError()\n  \n def build_dispatch_table(cls,code_dict,method_prefix):\n  if cls. DISPATCH_TABLE is not None :\n   return\n  table={}\n  for key,value in code_dict. items():\n   if hasattr(cls,\"%s%s\"%(method_prefix,key)):\n    table[value]=getattr(cls,\"%s%s\"%(method_prefix,key))\n  cls. DISPATCH_TABLE=table\n  \n build_dispatch_table=classmethod(build_dispatch_table)\n \n \nclass _OpcodeDispatcher(_Dispatcher):\n\n def __init__(self):\n  self. executing_contexts={}\n  self. at_dispatcher=_AtcodeDispatcher()\n  self. ch_dispatcher=_ChcodeDispatcher()\n  self. set_dispatcher=_CharsetDispatcher()\n  \n def match(self,context):\n  ''\n\n  \n  while context. remaining_codes()>0 and context. has_matched is None :\n   opcode=context. peek_code()\n   if not self. dispatch(opcode,context):\n    return None\n  if context. has_matched is None :\n   context. has_matched=False\n  return context. has_matched\n  \n def dispatch(self,opcode,context):\n  ''\n  \n  \n  if id(context)in self. executing_contexts:\n   generator=self. executing_contexts[id(context)]\n   del self. executing_contexts[id(context)]\n   has_finished=next(generator)\n  else :\n   method=self. DISPATCH_TABLE. get(opcode,_OpcodeDispatcher. unknown)\n   has_finished=method(self,context)\n   if hasattr(has_finished,\"__next__\"):\n    generator=has_finished\n    has_finished=next(generator)\n  if not has_finished:\n   self. executing_contexts[id(context)]=generator\n  return has_finished\n  \n def op_success(self,ctx):\n \n \n  ctx. state. string_position=ctx. string_position\n  ctx. has_matched=True\n  return True\n  \n def op_failure(self,ctx):\n \n \n  ctx. has_matched=False\n  return True\n  \n def general_op_literal(self,ctx,compare,decorate=lambda x:x):\n \n  if ctx. at_end()or not compare(decorate(ord(ctx. peek_char())),\n  decorate(ctx. peek_code(1))):\n   ctx. has_matched=False\n  ctx. skip_code(2)\n  ctx. skip_char(1)\n  \n def op_literal(self,ctx):\n \n \n \n  self. general_op_literal(ctx,operator. eq)\n  return True\n  \n def op_not_literal(self,ctx):\n \n \n \n  self. general_op_literal(ctx,operator. ne)\n  return True\n  \n def op_literal_ignore(self,ctx):\n \n \n \n  self. general_op_literal(ctx,operator. eq,ctx. state. lower)\n  return True\n  \n def op_not_literal_ignore(self,ctx):\n \n \n \n  self. general_op_literal(ctx,operator. ne,ctx. state. lower)\n  return True\n  \n def op_at(self,ctx):\n \n \n \n  if not self. at_dispatcher. dispatch(ctx. peek_code(1),ctx):\n   ctx. has_matched=False\n   \n   return True\n  ctx. skip_code(2)\n  return True\n  \n def op_category(self,ctx):\n \n \n \n  if ctx. at_end()or not self. ch_dispatcher. dispatch(ctx. peek_code(1),ctx):\n   ctx. has_matched=False\n   \n   return True\n  ctx. skip_code(2)\n  ctx. skip_char(1)\n  return True\n  \n def op_any(self,ctx):\n \n \n \n  if ctx. at_end()or ctx. at_linebreak():\n   ctx. has_matched=False\n   \n   return True\n  ctx. skip_code(1)\n  ctx. skip_char(1)\n  return True\n  \n def op_any_all(self,ctx):\n \n \n \n  if ctx. at_end():\n   ctx. has_matched=False\n   \n   return True\n  ctx. skip_code(1)\n  ctx. skip_char(1)\n  return True\n  \n def general_op_in(self,ctx,decorate=lambda x:x):\n \n \n  if ctx. at_end():\n   ctx. has_matched=False\n   \n   return\n  skip=ctx. peek_code(1)\n  ctx. skip_code(2)\n  \n  \n  if not self. check_charset(ctx,decorate(ord(ctx. peek_char()))):\n  \n   ctx. has_matched=False\n   return\n  ctx. skip_code(skip -1)\n  ctx. skip_char(1)\n  \n  \n def op_in(self,ctx):\n \n \n \n  self. general_op_in(ctx)\n  return True\n  \n def op_in_ignore(self,ctx):\n \n \n \n  self. general_op_in(ctx,ctx. state. lower)\n  return True\n  \n def op_jump(self,ctx):\n \n \n \n  ctx. skip_code(ctx. peek_code(1)+1)\n  return True\n  \n  \n  \n op_info=op_jump\n \n def op_mark(self,ctx):\n \n \n \n  ctx. state. set_mark(ctx. peek_code(1),ctx. string_position)\n  ctx. skip_code(2)\n  return True\n  \n def op_branch(self,ctx):\n \n \n \n  ctx. state. marks_push()\n  ctx. skip_code(1)\n  current_branch_length=ctx. peek_code(0)\n  while current_branch_length:\n  \n  \n   if not (ctx. peek_code(1)==OPCODES[\"literal\"]and   (ctx. at_end()or ctx. peek_code(2)!=ord(ctx. peek_char()))):\n    ctx. state. string_position=ctx. string_position\n    child_context=ctx. push_new_context(1)\n    \n    yield False\n    if child_context. has_matched:\n     ctx. has_matched=True\n     yield True\n    ctx. state. marks_pop_keep()\n   ctx. skip_code(current_branch_length)\n   current_branch_length=ctx. peek_code(0)\n  ctx. state. marks_pop_discard()\n  ctx. has_matched=False\n  \n  yield True\n  \n def op_repeat_one(self,ctx):\n \n \n \n \n  mincount=ctx. peek_code(2)\n  maxcount=ctx. peek_code(3)\n  \n  \n  \n  if ctx. remaining_chars()<mincount:\n   ctx. has_matched=False\n   yield True\n  ctx. state. string_position=ctx. string_position\n  count=self. count_repetitions(ctx,maxcount)\n  ctx. skip_char(count)\n  if count <mincount:\n   ctx. has_matched=False\n   yield True\n  if ctx. peek_code(ctx. peek_code(1)+1)==OPCODES[\"success\"]:\n  \n   ctx. state. string_position=ctx. string_position\n   ctx. has_matched=True\n   yield True\n   \n  ctx. state. marks_push()\n  if ctx. peek_code(ctx. peek_code(1)+1)==OPCODES[\"literal\"]:\n  \n  \n   char=ctx. peek_code(ctx. peek_code(1)+2)\n   while True :\n    while count >=mincount and    (ctx. at_end()or ord(ctx. peek_char())!=char):\n     ctx. skip_char(-1)\n     count -=1\n    if count <mincount:\n     break\n    ctx. state. string_position=ctx. string_position\n    child_context=ctx. push_new_context(ctx. peek_code(1)+1)\n    \n    yield False\n    if child_context. has_matched:\n     ctx. has_matched=True\n     yield True\n    ctx. skip_char(-1)\n    count -=1\n    ctx. state. marks_pop_keep()\n    \n  else :\n  \n   while count >=mincount:\n    ctx. state. string_position=ctx. string_position\n    child_context=ctx. push_new_context(ctx. peek_code(1)+1)\n    yield False\n    if child_context. has_matched:\n     ctx. has_matched=True\n     yield True\n    ctx. skip_char(-1)\n    count -=1\n    ctx. state. marks_pop_keep()\n    \n  ctx. state. marks_pop_discard()\n  ctx. has_matched=False\n  \n  yield True\n  \n def op_min_repeat_one(self,ctx):\n \n \n  mincount=ctx. peek_code(2)\n  maxcount=ctx. peek_code(3)\n  \n  \n  if ctx. remaining_chars()<mincount:\n   ctx. has_matched=False\n   yield True\n  ctx. state. string_position=ctx. string_position\n  if mincount ==0:\n   count=0\n  else :\n   count=self. count_repetitions(ctx,mincount)\n   if count <mincount:\n    ctx. has_matched=False\n    \n    yield True\n   ctx. skip_char(count)\n  if ctx. peek_code(ctx. peek_code(1)+1)==OPCODES[\"success\"]:\n  \n   ctx. state. string_position=ctx. string_position\n   ctx. has_matched=True\n   yield True\n   \n  ctx. state. marks_push()\n  while maxcount ==MAXREPEAT or count <=maxcount:\n   ctx. state. string_position=ctx. string_position\n   child_context=ctx. push_new_context(ctx. peek_code(1)+1)\n   \n   yield False\n   if child_context. has_matched:\n    ctx. has_matched=True\n    yield True\n   ctx. state. string_position=ctx. string_position\n   if self. count_repetitions(ctx,1)==0:\n    break\n   ctx. skip_char(1)\n   count +=1\n   ctx. state. marks_pop_keep()\n   \n  ctx. state. marks_pop_discard()\n  ctx. has_matched=False\n  yield True\n  \n def op_repeat(self,ctx):\n \n \n \n \n \n \n \n \n \n  repeat=_RepeatContext(ctx)\n  ctx. state. repeat=repeat\n  ctx. state. string_position=ctx. string_position\n  child_context=ctx. push_new_context(ctx. peek_code(1)+1)\n  \n  \n  \n  \n  yield False\n  ctx. state. repeat=repeat. previous\n  ctx. has_matched=child_context. has_matched\n  yield True\n  \n def op_max_until(self,ctx):\n \n \n  repeat=ctx. state. repeat\n  \n  if repeat is None :\n  \n   raise RuntimeError(\"Internal re error: MAX_UNTIL without REPEAT.\")\n  mincount=repeat. peek_code(2)\n  maxcount=repeat. peek_code(3)\n  ctx. state. string_position=ctx. string_position\n  count=repeat. count+1\n  \n  \n  if count <mincount:\n  \n   repeat. count=count\n   child_context=repeat. push_new_context(4)\n   yield False\n   ctx. has_matched=child_context. has_matched\n   if not ctx. has_matched:\n    repeat. count=count -1\n    ctx. state. string_position=ctx. string_position\n   yield True\n   \n  if (count <maxcount or maxcount ==MAXREPEAT)  and ctx. state. string_position !=repeat. last_position:\n  \n   repeat. count=count\n   ctx. state. marks_push()\n   save_last_position=repeat. last_position\n   repeat. last_position=ctx. state. string_position\n   child_context=repeat. push_new_context(4)\n   yield False\n   repeat. last_position=save_last_position\n   if child_context. has_matched:\n    ctx. state. marks_pop_discard()\n    ctx. has_matched=True\n    yield True\n   ctx. state. marks_pop()\n   repeat. count=count -1\n   ctx. state. string_position=ctx. string_position\n   \n   \n  ctx. state. repeat=repeat. previous\n  child_context=ctx. push_new_context(1)\n  \n  yield False\n  ctx. has_matched=child_context. has_matched\n  if not ctx. has_matched:\n   ctx. state. repeat=repeat\n   ctx. state. string_position=ctx. string_position\n  yield True\n  \n def op_min_until(self,ctx):\n \n \n  repeat=ctx. state. repeat\n  if repeat is None :\n   raise RuntimeError(\"Internal re error: MIN_UNTIL without REPEAT.\")\n  mincount=repeat. peek_code(2)\n  maxcount=repeat. peek_code(3)\n  ctx. state. string_position=ctx. string_position\n  count=repeat. count+1\n  \n  \n  if count <mincount:\n  \n   repeat. count=count\n   child_context=repeat. push_new_context(4)\n   yield False\n   ctx. has_matched=child_context. has_matched\n   if not ctx. has_matched:\n    repeat. count=count -1\n    ctx. state. string_position=ctx. string_position\n   yield True\n   \n   \n  ctx. state. marks_push()\n  ctx. state. repeat=repeat. previous\n  child_context=ctx. push_new_context(1)\n  \n  yield False\n  if child_context. has_matched:\n   ctx. has_matched=True\n   yield True\n  ctx. state. repeat=repeat\n  ctx. state. string_position=ctx. string_position\n  ctx. state. marks_pop()\n  \n  \n  if count >=maxcount and maxcount !=MAXREPEAT:\n   ctx. has_matched=False\n   \n   yield True\n  repeat. count=count\n  child_context=repeat. push_new_context(4)\n  yield False\n  ctx. has_matched=child_context. has_matched\n  if not ctx. has_matched:\n   repeat. count=count -1\n   ctx. state. string_position=ctx. string_position\n  yield True\n  \n def general_op_groupref(self,ctx,decorate=lambda x:x):\n  group_start,group_end=ctx. state. get_marks(ctx. peek_code(1))\n  if group_start is None or group_end is None or group_end <group_start:\n   ctx. has_matched=False\n   return True\n  while group_start <group_end:\n   if ctx. at_end()or decorate(ord(ctx. peek_char()))   !=decorate(ord(ctx. state. string[group_start])):\n    ctx. has_matched=False\n    \n    return True\n   group_start +=1\n   ctx. skip_char(1)\n  ctx. skip_code(2)\n  return True\n  \n def op_groupref(self,ctx):\n \n \n \n  return self. general_op_groupref(ctx)\n  \n def op_groupref_ignore(self,ctx):\n \n \n \n  return self. general_op_groupref(ctx,ctx. state. lower)\n  \n def op_groupref_exists(self,ctx):\n \n \n  group_start,group_end=ctx. state. get_marks(ctx. peek_code(1))\n  if group_start is None or group_end is None or group_end <group_start:\n   ctx. skip_code(ctx. peek_code(2)+1)\n  else :\n   ctx. skip_code(3)\n  return True\n  \n def op_assert(self,ctx):\n \n \n \n  ctx. state. string_position=ctx. string_position -ctx. peek_code(2)\n  if ctx. state. string_position <0:\n   ctx. has_matched=False\n   yield True\n  child_context=ctx. push_new_context(3)\n  yield False\n  if child_context. has_matched:\n   ctx. skip_code(ctx. peek_code(1)+1)\n  else :\n   ctx. has_matched=False\n  yield True\n  \n def op_assert_not(self,ctx):\n \n \n \n  ctx. state. string_position=ctx. string_position -ctx. peek_code(2)\n  if ctx. state. string_position >=0:\n   child_context=ctx. push_new_context(3)\n   yield False\n   if child_context. has_matched:\n    ctx. has_matched=False\n    yield True\n  ctx. skip_code(ctx. peek_code(1)+1)\n  yield True\n  \n def unknown(self,ctx):\n \n  raise RuntimeError(\"Internal re error. Unknown opcode: %s\"%ctx. peek_code())\n  \n def check_charset(self,ctx,char):\n  ''\n  \n  self. set_dispatcher. reset(char)\n  save_position=ctx. code_position\n  result=None\n  while result is None :\n   result=self. set_dispatcher. dispatch(ctx. peek_code(),ctx)\n  ctx. code_position=save_position\n  \n  return result\n  \n def count_repetitions(self,ctx,maxcount):\n  ''\n\n  \n  count=0\n  real_maxcount=ctx. state. end -ctx. string_position\n  if maxcount <real_maxcount and maxcount !=MAXREPEAT:\n   real_maxcount=maxcount\n   \n   \n   \n  code_position=ctx. code_position\n  string_position=ctx. string_position\n  ctx. skip_code(4)\n  reset_position=ctx. code_position\n  while count <real_maxcount:\n  \n  \n   ctx. code_position=reset_position\n   self. dispatch(ctx. peek_code(),ctx)\n   \n   if ctx. has_matched is False :\n    break\n   count +=1\n  ctx. has_matched=None\n  ctx. code_position=code_position\n  ctx. string_position=string_position\n  return count\n  \n def _log(self,context,opname,*args):\n  arg_string=(\"%s \"*len(args))%args\n  _log(\"|%s|%s|%s %s\"%(context. pattern_codes,\n  context. string_position,opname,arg_string))\n  \n_OpcodeDispatcher. build_dispatch_table(OPCODES,\"op_\")\n\n\nclass _CharsetDispatcher(_Dispatcher):\n\n def __init__(self):\n  self. ch_dispatcher=_ChcodeDispatcher()\n  \n def reset(self,char):\n  self. char=char\n  self. ok=True\n  \n def set_failure(self,ctx):\n  return not self. ok\n def set_literal(self,ctx):\n \n  if ctx. peek_code(1)==self. char:\n   return self. ok\n  else :\n   ctx. skip_code(2)\n def set_category(self,ctx):\n \n  if self. ch_dispatcher. dispatch(ctx. peek_code(1),ctx):\n   return self. ok\n  else :\n   ctx. skip_code(2)\n def set_charset(self,ctx):\n \n  char_code=self. char\n  ctx. skip_code(1)\n  if CODESIZE ==2:\n   if char_code <256 and ctx. peek_code(char_code >>4)   &(1 <<(char_code&15)):\n    return self. ok\n   ctx. skip_code(16)\n  else :\n   if char_code <256 and ctx. peek_code(char_code >>5)   &(1 <<(char_code&31)):\n    return self. ok\n   ctx. skip_code(8)\n def set_range(self,ctx):\n \n  if ctx. peek_code(1)<=self. char <=ctx. peek_code(2):\n   return self. ok\n  ctx. skip_code(3)\n def set_negate(self,ctx):\n  self. ok=not self. ok\n  ctx. skip_code(1)\n  \n  \n def set_bigcharset(self,ctx):\n  raise NotImplementedError(\"_sre.py: set_bigcharset, array not implemented\")\n  \n  char_code=self. char\n  count=ctx. peek_code(1)\n  ctx. skip_code(2)\n  if char_code <65536:\n   block_index=char_code >>8\n   \n   a=array. array(\"B\")\n   a. fromstring(array. array(CODESIZE ==2 and\"H\"or\"I\",\n   [ctx. peek_code(block_index //CODESIZE)]). tostring())\n   block=a[block_index %CODESIZE]\n   ctx. skip_code(256 //CODESIZE)\n   block_value=ctx. peek_code(block *(32 //CODESIZE)\n   +((char_code&255)>>(CODESIZE ==2 and 4 or 5)))\n   if block_value&(1 <<(char_code&((8 *CODESIZE)-1))):\n    return self. ok\n  else :\n   ctx. skip_code(256 //CODESIZE)\n  ctx. skip_code(count *(32 //CODESIZE))\n  \n def unknown(self,ctx):\n  return False\n  \n_CharsetDispatcher. build_dispatch_table(OPCODES,\"set_\")\n\n\nclass _AtcodeDispatcher(_Dispatcher):\n\n def at_beginning(self,ctx):\n  return ctx. at_beginning()\n at_beginning_string=at_beginning\n def at_beginning_line(self,ctx):\n  return ctx. at_beginning()or _is_linebreak(ctx. peek_char(-1))\n def at_end(self,ctx):\n  return (ctx. remaining_chars()==1 and ctx. at_linebreak())or ctx. at_end()\n def at_end_line(self,ctx):\n  return ctx. at_linebreak()or ctx. at_end()\n def at_end_string(self,ctx):\n  return ctx. at_end()\n def at_boundary(self,ctx):\n  return ctx. at_boundary(_is_word)\n def at_non_boundary(self,ctx):\n  return not ctx. at_boundary(_is_word)\n def at_loc_boundary(self,ctx):\n  return ctx. at_boundary(_is_loc_word)\n def at_loc_non_boundary(self,ctx):\n  return not ctx. at_boundary(_is_loc_word)\n def at_uni_boundary(self,ctx):\n  return ctx. at_boundary(_is_uni_word)\n def at_uni_non_boundary(self,ctx):\n  return not ctx. at_boundary(_is_uni_word)\n def unknown(self,ctx):\n  return False\n  \n_AtcodeDispatcher. build_dispatch_table(ATCODES,\"\")\n\n\nclass _ChcodeDispatcher(_Dispatcher):\n\n def category_digit(self,ctx):\n  return _is_digit(ctx. peek_char())\n def category_not_digit(self,ctx):\n  return not _is_digit(ctx. peek_char())\n def category_space(self,ctx):\n  return _is_space(ctx. peek_char())\n def category_not_space(self,ctx):\n  return not _is_space(ctx. peek_char())\n def category_word(self,ctx):\n  return _is_word(ctx. peek_char())\n def category_not_word(self,ctx):\n  return not _is_word(ctx. peek_char())\n def category_linebreak(self,ctx):\n  return _is_linebreak(ctx. peek_char())\n def category_not_linebreak(self,ctx):\n  return not _is_linebreak(ctx. peek_char())\n def category_loc_word(self,ctx):\n  return _is_loc_word(ctx. peek_char())\n def category_loc_not_word(self,ctx):\n  return not _is_loc_word(ctx. peek_char())\n def category_uni_digit(self,ctx):\n  return ctx. peek_char(). isdigit()\n def category_uni_not_digit(self,ctx):\n  return not ctx. peek_char(). isdigit()\n def category_uni_space(self,ctx):\n  return ctx. peek_char(). isspace()\n def category_uni_not_space(self,ctx):\n  return not ctx. peek_char(). isspace()\n def category_uni_word(self,ctx):\n  return _is_uni_word(ctx. peek_char())\n def category_uni_not_word(self,ctx):\n  return not _is_uni_word(ctx. peek_char())\n def category_uni_linebreak(self,ctx):\n  return ord(ctx. peek_char())in _uni_linebreaks\n def category_uni_not_linebreak(self,ctx):\n  return ord(ctx. peek_char())not in _uni_linebreaks\n def unknown(self,ctx):\n  return False\n  \n_ChcodeDispatcher. build_dispatch_table(CHCODES,\"\")\n\n\n_ascii_char_info=[0,0,0,0,0,0,0,0,0,2,6,2,\n2,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,0,0,\n0,0,0,0,0,0,0,0,0,0,0,0,0,25,25,25,25,25,25,25,25,\n25,25,0,0,0,0,0,0,0,24,24,24,24,24,24,24,24,24,24,\n24,24,24,24,24,24,24,24,24,24,24,24,24,24,24,24,0,0,\n0,0,16,0,24,24,24,24,24,24,24,24,24,24,24,24,24,24,\n24,24,24,24,24,24,24,24,24,24,24,24,0,0,0,0,0]\n\ndef _is_digit(char):\n code=ord(char)\n return code <128 and _ascii_char_info[code]&1\n \ndef _is_space(char):\n code=ord(char)\n return code <128 and _ascii_char_info[code]&2\n \ndef _is_word(char):\n\n code=ord(char)\n return code <128 and _ascii_char_info[code]&16\n \ndef _is_loc_word(char):\n return (not (ord(char)&~255)and char. isalnum())or char =='_'\n \ndef _is_uni_word(char):\n\n\n return chr(ord(char)). isalnum()or char =='_'\n \ndef _is_linebreak(char):\n return char ==\"\\n\"\n \n \n_uni_linebreaks=[10,13,28,29,30,133,8232,8233]\n\ndef _log(message):\n if 0:\n  print(message)\n"], "sre_compile": [".py", "\n\n\n\n\n\n\n\n\n\n\"\"\"Internal support module for sre\"\"\"\n\n\nimport sys\nimport _sre\nimport sre_parse\nfrom sre_constants import *\nfrom _sre import MAXREPEAT\n\n\nassert _sre. MAGIC ==MAGIC,\"SRE module mismatch\"\n\nif _sre. CODESIZE ==2:\n MAXCODE=65535\nelse :\n MAXCODE=0xFFFFFFFF\n \ndef _identityfunction(x):\n return x\n \n \n_LITERAL_CODES=set([LITERAL,NOT_LITERAL])\n_REPEATING_CODES=set([REPEAT,MIN_REPEAT,MAX_REPEAT])\n_SUCCESS_CODES=set([SUCCESS,FAILURE])\n_ASSERT_CODES=set([ASSERT,ASSERT_NOT])\n\ndef _compile(code,pattern,flags):\n\n emit=code. append\n _len=len\n LITERAL_CODES=_LITERAL_CODES\n REPEATING_CODES=_REPEATING_CODES\n SUCCESS_CODES=_SUCCESS_CODES\n ASSERT_CODES=_ASSERT_CODES\n for op,av in pattern:\n \n \n  if op in LITERAL_CODES:\n   if flags&SRE_FLAG_IGNORECASE:\n    emit(OPCODES[OP_IGNORE[op]])\n    emit(_sre. getlower(av,flags))\n   else :\n    emit(OPCODES[op])\n    emit(av)\n  elif op is IN:\n   if flags&SRE_FLAG_IGNORECASE:\n    emit(OPCODES[OP_IGNORE[op]])\n    def fixup(literal,flags=flags):\n     return _sre. getlower(literal,flags)\n   else :\n    emit(OPCODES[op])\n    fixup=_identityfunction\n   skip=_len(code);emit(0)\n   _compile_charset(av,flags,code,fixup)\n   code[skip]=_len(code)-skip\n  elif op is ANY:\n   if flags&SRE_FLAG_DOTALL:\n    emit(OPCODES[ANY_ALL])\n   else :\n    emit(OPCODES[ANY])\n  elif op in REPEATING_CODES:\n   if flags&SRE_FLAG_TEMPLATE:\n    raise error(\"internal: unsupported template operator\")\n    emit(OPCODES[REPEAT])\n    skip=_len(code);emit(0)\n    emit(av[0])\n    emit(av[1])\n    _compile(code,av[2],flags)\n    emit(OPCODES[SUCCESS])\n    code[skip]=_len(code)-skip\n   elif _simple(av)and op is not REPEAT:\n    if op is MAX_REPEAT:\n     emit(OPCODES[REPEAT_ONE])\n    else :\n     emit(OPCODES[MIN_REPEAT_ONE])\n    skip=_len(code);emit(0)\n    emit(av[0])\n    emit(av[1])\n    _compile(code,av[2],flags)\n    emit(OPCODES[SUCCESS])\n    code[skip]=_len(code)-skip\n   else :\n    emit(OPCODES[REPEAT])\n    skip=_len(code);emit(0)\n    emit(av[0])\n    emit(av[1])\n    _compile(code,av[2],flags)\n    code[skip]=_len(code)-skip\n    if op is MAX_REPEAT:\n     emit(OPCODES[MAX_UNTIL])\n    else :\n     emit(OPCODES[MIN_UNTIL])\n  elif op is SUBPATTERN:\n   if av[0]:\n    emit(OPCODES[MARK])\n    emit((av[0]-1)*2)\n    \n   _compile(code,av[1],flags)\n   if av[0]:\n    emit(OPCODES[MARK])\n    emit((av[0]-1)*2+1)\n  elif op in SUCCESS_CODES:\n   emit(OPCODES[op])\n  elif op in ASSERT_CODES:\n   emit(OPCODES[op])\n   skip=_len(code);emit(0)\n   if av[0]>=0:\n    emit(0)\n   else :\n    lo,hi=av[1]. getwidth()\n    if lo !=hi:\n     raise error(\"look-behind requires fixed-width pattern\")\n    emit(lo)\n   _compile(code,av[1],flags)\n   emit(OPCODES[SUCCESS])\n   code[skip]=_len(code)-skip\n  elif op is CALL:\n   emit(OPCODES[op])\n   skip=_len(code);emit(0)\n   _compile(code,av,flags)\n   emit(OPCODES[SUCCESS])\n   code[skip]=_len(code)-skip\n  elif op is AT:\n   emit(OPCODES[op])\n   if flags&SRE_FLAG_MULTILINE:\n    av=AT_MULTILINE. get(av,av)\n   if flags&SRE_FLAG_LOCALE:\n    av=AT_LOCALE. get(av,av)\n   elif flags&SRE_FLAG_UNICODE:\n    av=AT_UNICODE. get(av,av)\n   emit(ATCODES[av])\n  elif op is BRANCH:\n   emit(OPCODES[op])\n   tail=[]\n   tailappend=tail. append\n   for av in av[1]:\n    skip=_len(code);emit(0)\n    \n    _compile(code,av,flags)\n    emit(OPCODES[JUMP])\n    tailappend(_len(code));emit(0)\n    code[skip]=_len(code)-skip\n   emit(0)\n   for tail in tail:\n    code[tail]=_len(code)-tail\n  elif op is CATEGORY:\n   emit(OPCODES[op])\n   if flags&SRE_FLAG_LOCALE:\n    av=CH_LOCALE[av]\n   elif flags&SRE_FLAG_UNICODE:\n    av=CH_UNICODE[av]\n   emit(CHCODES[av])\n  elif op is GROUPREF:\n   if flags&SRE_FLAG_IGNORECASE:\n    emit(OPCODES[OP_IGNORE[op]])\n   else :\n    emit(OPCODES[op])\n   emit(av -1)\n  elif op is GROUPREF_EXISTS:\n   emit(OPCODES[op])\n   emit(av[0]-1)\n   skipyes=_len(code);emit(0)\n   _compile(code,av[1],flags)\n   if av[2]:\n    emit(OPCODES[JUMP])\n    skipno=_len(code);emit(0)\n    code[skipyes]=_len(code)-skipyes+1\n    _compile(code,av[2],flags)\n    code[skipno]=_len(code)-skipno\n   else :\n    code[skipyes]=_len(code)-skipyes+1\n  else :\n   raise ValueError(\"unsupported operand type\",op)\n   \ndef _compile_charset(charset,flags,code,fixup=None ):\n\n emit=code. append\n if fixup is None :\n  fixup=_identityfunction\n for op,av in _optimize_charset(charset,fixup):\n  emit(OPCODES[op])\n  if op is NEGATE:\n   pass\n  elif op is LITERAL:\n   emit(fixup(av))\n  elif op is RANGE:\n   emit(fixup(av[0]))\n   emit(fixup(av[1]))\n  elif op is CHARSET:\n   code. extend(av)\n  elif op is BIGCHARSET:\n   code. extend(av)\n  elif op is CATEGORY:\n   if flags&SRE_FLAG_LOCALE:\n    emit(CHCODES[CH_LOCALE[av]])\n   elif flags&SRE_FLAG_UNICODE:\n    emit(CHCODES[CH_UNICODE[av]])\n   else :\n    emit(CHCODES[av])\n  else :\n   raise error(\"internal: unsupported set operator\")\n emit(OPCODES[FAILURE])\n \n \ndef _optimize_charset(charset,fixup):\n\n out=[]\n outappend=out. append\n charmap=[0]*256\n try :\n  for op,av in charset:\n   if op is NEGATE:\n    outappend((op,av))\n   elif op is LITERAL:\n    charmap[fixup(av)]=1\n   elif op is RANGE:\n    for i in range(fixup(av[0]),fixup(av[1])+1):\n     charmap[i]=1\n   elif op is CATEGORY:\n   \n    return charset\n except IndexError:\n \n  return _optimize_unicode(charset,fixup)\n  \n i=p=n=0\n runs=[]\n runsappend=runs. append\n for c in charmap:\n  if c:\n   if n ==0:\n    p=i\n   n=n+1\n  elif n:\n   runsappend((p,n))\n   n=0\n  i=i+1\n if n:\n  runsappend((p,n))\n if len(runs)<=2:\n \n  for p,n in runs:\n   if n ==1:\n    outappend((LITERAL,p))\n   else :\n    outappend((RANGE,(p,p+n -1)))\n  if len(out)<len(charset):\n   return out\n else :\n \n  data=_mk_bitmap(charmap)\n  outappend((CHARSET,data))\n  return out\n return charset\n \ndef _mk_bitmap(bits):\n data=[]\n dataappend=data. append\n if _sre. CODESIZE ==2:\n  start=(1,0)\n else :\n  start=(1,0)\n m,v=start\n for c in bits:\n  if c:\n   v=v+m\n  m=m+m\n  if m >MAXCODE:\n   dataappend(v)\n   m,v=start\n return data\n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \ndef _optimize_unicode(charset,fixup):\n try :\n  import array\n except ImportError:\n  return charset\n charmap=[0]*65536\n negate=0\n try :\n  for op,av in charset:\n   if op is NEGATE:\n    negate=1\n   elif op is LITERAL:\n    charmap[fixup(av)]=1\n   elif op is RANGE:\n    for i in range(fixup(av[0]),fixup(av[1])+1):\n     charmap[i]=1\n   elif op is CATEGORY:\n   \n    return charset\n except IndexError:\n \n  return charset\n if negate:\n  if sys. maxunicode !=65535:\n  \n  \n  \n   return charset\n  for i in range(65536):\n   charmap[i]=not charmap[i]\n comps={}\n mapping=[0]*256\n block=0\n data=[]\n for i in range(256):\n  chunk=tuple(charmap[i *256:(i+1)*256])\n  new=comps. setdefault(chunk,block)\n  mapping[i]=new\n  if new ==block:\n   block=block+1\n   data=data+_mk_bitmap(chunk)\n header=[block]\n if _sre. CODESIZE ==2:\n  code='H'\n else :\n  code='I'\n  \n mapping=array. array('b',mapping). tobytes()\n \n mapping=array. array(code,mapping)\n assert mapping. itemsize ==_sre. CODESIZE\n assert len(mapping)*mapping. itemsize ==256\n header=header+mapping. tolist()\n data[0:0]=header\n return [(BIGCHARSET,data)]\n \ndef _simple(av):\n\n lo,hi=av[2]. getwidth()\n if lo ==0 and hi ==MAXREPEAT:\n  raise error(\"nothing to repeat\")\n return lo ==hi ==1 and av[2][0][0]!=SUBPATTERN\n \ndef _compile_info(code,pattern,flags):\n\n\n\n lo,hi=pattern. getwidth()\n \n if lo ==0:\n  return\n  \n prefix=[]\n prefixappend=prefix. append\n prefix_skip=0\n charset=[]\n charsetappend=charset. append\n if not (flags&SRE_FLAG_IGNORECASE):\n \n  for op,av in pattern. data:\n  \n   if op is LITERAL:\n    if len(prefix)==prefix_skip:\n     prefix_skip=prefix_skip+1\n    prefixappend(av)\n   elif op is SUBPATTERN and len(av[1])==1:\n    op,av=av[1][0]\n    if op is LITERAL:\n     prefixappend(av)\n    else :\n     break\n   else :\n    break\n    \n  if not prefix and pattern. data:\n   op,av=pattern. data[0]\n   if op is SUBPATTERN and av[1]:\n    op,av=av[1][0]\n    if op is LITERAL:\n     charsetappend((op,av))\n    elif op is BRANCH:\n     c=[]\n     cappend=c. append\n     for p in av[1]:\n      if not p:\n       break\n      op,av=p[0]\n      if op is LITERAL:\n       cappend((op,av))\n      else :\n       break\n     else :\n      charset=c\n   elif op is BRANCH:\n    c=[]\n    cappend=c. append\n    for p in av[1]:\n     if not p:\n      break\n     op,av=p[0]\n     if op is LITERAL:\n      cappend((op,av))\n     else :\n      break\n    else :\n     charset=c\n   elif op is IN:\n    charset=av\n    \n    \n    \n    \n    \n    \n    \n emit=code. append\n emit(OPCODES[INFO])\n skip=len(code);emit(0)\n \n mask=0\n if prefix:\n  mask=SRE_INFO_PREFIX\n  if len(prefix)==prefix_skip ==len(pattern. data):\n   mask=mask+SRE_INFO_LITERAL\n elif charset:\n  mask=mask+SRE_INFO_CHARSET\n emit(mask)\n \n if lo <MAXCODE:\n  emit(lo)\n else :\n  emit(MAXCODE)\n  prefix=prefix[:MAXCODE]\n if hi <MAXCODE:\n  emit(hi)\n else :\n  emit(0)\n  \n  \n if prefix:\n  emit(len(prefix))\n  emit(prefix_skip)\n  code. extend(prefix)\n  \n  table=[-1]+([0]*len(prefix))\n  for i in range(len(prefix)):\n   table[i+1]=table[i]+1\n   while table[i+1]>0 and prefix[i]!=prefix[table[i+1]-1]:\n    table[i+1]=table[table[i+1]-1]+1\n  code. extend(table[1:])\n elif charset:\n  _compile_charset(charset,flags,code)\n code[skip]=len(code)-skip\n \ndef isstring(obj):\n return isinstance(obj,(str,bytes))\n \ndef _code(p,flags):\n\n flags=p. pattern. flags |flags\n code=[]\n \n \n _compile_info(code,p,flags)\n \n \n _compile(code,p. data,flags)\n \n code. append(OPCODES[SUCCESS])\n \n return code\n \ndef compile(p,flags=0):\n\n\n\n if isstring(p):\n  pattern=p\n  p=sre_parse. parse(p,flags)\n else :\n  pattern=None\n  \n  \n code=_code(p,flags)\n \n \n \n \n \n if p. pattern. groups >100:\n  raise AssertionError(\n  \"sorry, but this version only supports 100 named groups\"\n  )\n  \n  \n groupindex=p. pattern. groupdict\n indexgroup=[None ]*p. pattern. groups\n for k,i in groupindex. items():\n  indexgroup[i]=k\n  \n return _sre. compile(\n pattern,flags |p. pattern. flags,code,\n p. pattern. groups -1,\n groupindex,indexgroup\n )\n"], "_sys": [".js", "var $module=(function($B){\n    var _b_=$B.builtins\n    return {\n        // Called \"Getframe\" because \"_getframe\" wouldn't be imported in \n        // sys.py with \"from _sys import *\"\n        Getframe : function(depth){\n            return $B._frame($B.frames_stack, depth)\n        },\n        modules :\n            {'__get__':function(){return $B.obj_dict($B.imported)},\n             '__set__':function(self, obj, value){ throw _b_.TypeError(\"Read only property 'sys.modules'\") }\n            },\n        path: \n            {'__get__':function(){return $B.path},\n             '__set__':function(self, obj, value){ $B.path = value }\n            },\n        meta_path: \n            {'__get__':function(){return $B.meta_path},\n             '__set__':function(self, obj, value){ $B.meta_path = value }\n            },\n        path_hooks: \n            {'__get__':function(){return $B.path_hooks},\n             '__set__':function(self, obj, value){ $B.path_hooks = value }\n            },\n        path_importer_cache: \n            {'__get__':function(){return _b_.dict($B.JSObject($B.path_importer_cache))},\n             '__set__':function(self, obj, value){ throw _b_.TypeError(\"Read only property 'sys.path_importer_cache'\") }\n            },\n        stderr : {\n            __get__:function(){return $B.stderr},\n            __set__:function(self, obj, value){$B.stderr = value},\n            write:function(data){_b_.getattr($B.stderr,\"write\")(data)}\n            },\n        stdout : {\n            __get__:function(){return $B.stdout},\n            __set__:function(self, obj, value){$B.stdout = value},\n            write:function(data){_b_.getattr($B.stdout,\"write\")(data)}\n            },\n        stdin : $B.stdin\n    }\n})(__BRYTHON__)\n"], "_jsre": [".js", "var $module=(function($B){\n\n    var _b_ = $B.builtins\n    var $s=[]\n    for(var $b in _b_) $s.push('var ' + $b +'=_b_[\"'+$b+'\"]')\n    eval($s.join(';'))\n\n    var JSObject = $B.JSObject\n\n    var obj = {__class__:$module,\n        __str__: function(){return \"<module 're'>\"}\n    }\n    obj.A = obj.ASCII = 256\n    obj.I = obj.IGNORECASE = 2 // 'i'\n    obj.L = obj.LOCALE = 4\n    obj.M = obj.MULTILINE = 8 // 'm'\n    obj.S = obj.DOTALL = 16\n    obj.U = obj.UNICODE = 32\n    obj.X = obj.VERBOSE = 64\n    obj._is_valid = function(pattern) {\n        if ($B.$options.re=='pyre') return false  //force use of python's re module\n        if ($B.$options.re=='jsre') return true   //force use of brythons re module\n        // FIXME: Improve\n\n        if (!isinstance(pattern, str)) {\n           // this is probably a SRE_PATTERN, so return false, and let\n           // python's re module handle this.\n           return false\n        }\n        var is_valid = false;\n        try {\n            new RegExp(pattern);\n            is_valid = true;\n        }\n        catch(e) {}\n        if (!is_valid) return false  //if js won't parse the pattern return false\n\n        // using reference http://www.regular-expressions.info/\n        // to compare python re and javascript regex libraries\n\n        // look for things javascript does not support\n        // check for name capturing group\n        var mylist=['?P=', '?P<', '(?#', '(?<=', '(?<!', '(?(']\n        for(var i=0, _len_i = mylist.length; i < _len_i; i++) {\n           if (pattern.indexOf(mylist[i]) > -1) return false\n        }\n\n        var re_list=['\\{,\\d+\\}']\n        for(var i=0, _len_i = re_list.length; i < _len_i; i++) {\n           var _re=new RegExp(re_list[i])\n           if (_re.test(pattern)) return false\n        }\n\n        // it looks like the pattern has passed all our tests so lets assume\n        // javascript can handle this pattern.\n        return true\n    }\n    var $SRE_PatternDict = {\n        __class__:$B.$type,\n        __name__:'SRE_Pattern'\n    }\n    $SRE_PatternDict.__mro__ = [object.$dict]\n    $SRE_PatternDict.findall = function(self,string){\n        return obj.findall(self.pattern,string,self.flags)\n    }\n    $SRE_PatternDict.finditer = function(self,string){\n        return obj.finditer(self.pattern,string,self.flags)\n    }\n    $SRE_PatternDict.match = function(self,string){\n        return obj.match(self.pattern,string,self.flags)\n    }\n    $SRE_PatternDict.search = function(self,string){\n        return obj.search(self.pattern,string,self.flags)\n    }\n    function normflags(flags) {\n        return ((flags & obj.I)? 'i' : '') + ((flags & obj.M)? 'm' : '');\n    }\n    obj.compile = function(pattern,flags){\n        return {\n            __class__:$SRE_PatternDict,\n            pattern:pattern,\n            flags:normflags(flags)\n        }\n    }\n    obj.escape = function(string){\n        // Escape all the characters in pattern except ASCII letters, numbers \n        // and '_'. This is useful if you want to match an arbitrary literal \n        // string that may have regular expression metacharacters in it.\n        var res = ''\n        var ok = 'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789_'\n        for(var i=0, _len_i = string.length; i < _len_i;i++){\n            if(ok.search(string.charAt(i))>-1){res += string.charAt(i)}\n        }\n        return res\n    }\n    obj.findall = function(pattern,string,flags){\n        var $ns=$B.args('re.findall',2,\n            {pattern:null, string:null}, ['pattern', 'string'],\n            arguments,{},'args','kw') ,\n            args = $ns['args'] ,\n            _flags = 0;\n        if(args.length>0){var flags=args[0]}\n        else{var _flags = getattr($ns['kw'], 'get')('flags',0)}\n        \n        var flags = normflags();\n        flags += 'gm'\n        var jsp = new RegExp(pattern,flags) ,\n            jsmatch = string.match(jsp);\n        if(jsmatch===null){return []}\n        return jsmatch\n    }\n    obj.finditer = function(pattern,string,flags){\n        var $ns=$B.args('re.finditer',2,\n            {pattern:null, sring:null}, ['pattern','string'],\n            arguments,{},'args','kw'),\n            args = $ns['args'],\n            _flags = 0;\n        if(args.length>0){var flags=args[0]}\n        else{var _flags = getattr($ns['kw'], 'get')('flags',0)}\n        \n        var flags = normflags();\n        flags += 'gm'\n        var jsp = new RegExp(pattern,flags),\n            jsmatch = string.match(jsp);\n        if(jsmatch===null){return []}\n        \n        var _list=[]\n        for (var j=0, _len_j = jsmatch.length; j < _len_j; j++) {\n            var mo = {}\n            mo._match=jsmatch[j]\n            mo.group = function(){\n               var res = []\n               for(var i=0, _len_i = arguments.length; i < _len_i;i++){\n                   if(jsmatch[arguments[i]]===undefined){res.push(None)}\n                   else{res.push(jsmatch[arguments[i]])}\n               }\n               if(arguments.length===1){return res[0]}\n               return tuple(res)\n            }\n            mo.groups = function(_default){\n               if(_default===undefined){_default=None}\n               var res = []\n               for(var i=1, _len_i = jsmatch.length; i < _len_i;i++){\n                  if(jsmatch[i]===undefined){res.push(_default)}\n                  else{res.push(jsmatch[i])}\n               }\n               return tuple(res)\n            }\n            mo.start = function(){return mo._match.index}\n            mo.end = function(){return mo._match.length-mo._match.index}\n            mo.string = string\n            _list.push(JSObject(mo))\n        }\n        return _list\n    }\n    obj.search = function(pattern,string){\n        var $ns=$B.args('re.search', 2,\n            {pattern:null, string:null},['pattern','string'],\n            arguments,{},'args','kw')\n        var args = $ns['args']\n        if(args.length>0){var flags=args[0]}\n        else{var flags = getattr($ns['kw'],'get')('flags','')}\n        flags = normflags(flags);\n        var jsp = new RegExp(pattern,flags)\n        var jsmatch = string.match(jsp)\n        if(jsmatch===null){return None}\n        var mo = new Object()\n        mo.group = function(){\n            var res = []\n            for(var i=0, _len_i = arguments.length; i < _len_i;i++){\n                if(jsmatch[arguments[i]]===undefined){res.push(None)}\n                else{res.push(jsmatch[arguments[i]])}\n            }\n            if(arguments.length===1){return res[0]}\n            return tuple(res)\n        }\n        mo.groups = function(_default){\n            if(_default===undefined){_default=None}\n            var res = []\n            for(var i=1, _len_i = jsmatch.length; i < _len_i;i++){\n                if(jsmatch[i]===undefined){res.push(_default)}\n                else{res.push(jsmatch[i])}\n            }\n            return tuple(res)\n        }\n        mo.start = function(){return jsmatch.index}\n        mo.end = function(){return jsmatch.length-jsmatch.index}\n        mo.string = string\n        return JSObject(mo)\n    }\n    obj.sub = function(pattern,repl,string){\n        var $ns=$B.args('re.search', 3,\n            {pattern:null, repl:null, string:null}, \n            ['pattern','repl','string'],\n            arguments,{},'args','kw')\n        for($var in $ns){eval(\"var \"+$var+\"=$ns[$var]\")}\n        var args = $ns['args']\n        var count = _b_.dict.$dict.get($ns['kw'],'count',0)\n        var flags = _b_.dict.$dict.get($ns['kw'],'flags','')\n        if(args.length>0){var count=args[0]}\n        if(args.length>1){var flags=args[1]}\n        flags = normflags(flags);\n        if(typeof repl===\"string\"){\n            // backreferences are \\1, \\2... in Python but $1,$2... in Javascript\n            repl = repl.replace(/\\\\(\\d+)/g,'$$$1')\n        }else if(typeof repl===\"function\"){\n            // the argument passed to the Python function is the match object\n            // the arguments passed to the Javascript function are :\n            // - the matched substring\n            // - the matched groups\n            // - the offset of the matched substring inside the string\n            // - the string being examined\n            var $repl1 = function(){\n                var mo = Object()\n                mo.string = arguments[arguments.length-1]\n                var start = arguments[arguments.length-2]\n                var end = start + arguments[0].length\n                mo.start = function(){return start}\n                mo.end = function(){return end}\n                groups = []\n                for(var i=1, _len_i = arguments.length-2; i < _len_i;i++){groups.push(arguments[i])}\n                mo.groups = function(_default){\n                    if(_default===undefined){_default=None}\n                    var res = []\n                    for(var i=0, _len_i = groups.length; i < _len_i;i++){\n                        if(groups[i]===undefined){res.push(_default)}\n                        else{res.push(groups[i])}\n                    }\n                    return res\n                }\n                return repl(JSObject(mo))\n            }\n        }\n        if(count==0){flags+='g'}\n        var jsp = new RegExp(pattern,flags)\n        if(typeof repl==='function'){return string.replace(jsp,$repl1)}\n        else{return string.replace(jsp,repl)}\n    }\n    obj.match = (function(search_func){\n        return function(){\n            // match is like search but pattern must start with ^\n            var pattern = arguments[0]\n            if(pattern.charAt(0)!=='^'){pattern = '^'+pattern}\n            var args = [pattern]\n            for(var i=1, _len_i = arguments.length; i < _len_i;i++){args.push(arguments[i])}\n            return search_func.apply(null,args)\n        }\n    })(obj.search)\n\n    return obj\n}\n)(__BRYTHON__)\n"], "browser.html": [".py", "from _html import *"], "operator": [".py", "#!/usr/bin/env python3\n''\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\ndef lt(a,b):\n ''\n return a <b\n__lt__=lt\n\ndef le(a,b):\n ''\n return a <=b\n__le__=le\n\ndef eq(a,b):\n ''\n return a ==b\n__eq__=eq\n\ndef ne(a,b):\n ''\n return a !=b\n__ne__=ne\n\ndef ge(a,b):\n ''\n return a >=b\n__ge__=ge\n\ndef gt(a,b):\n ''\n return a >b\n__gt__=gt\n\ndef not_(a):\n ''\n return not a\n__not__=not_\n\ndef truth(a):\n ''\n \n return bool(a)\n \ndef is_(a,b):\n ''\n return a is b\n \n \n \n \n \n \n \n \n \n \n \n__abs__=abs\nabs=abs\n\n\ndef add(a,b):\n ''\n return a+b\n__add__=add\n\ndef and_(a,b):\n ''\n return a&b\n__and__=and_\n\ndef floordiv(a,b):\n ''\n return a //b\n__floordiv__=floordiv\n\ndef index(a):\n ''\n return a. __index__()\n__index__=index\n\ndef inv(a):\n ''\n return ~a\n \ninvert=__inv__=__invert__=inv\n\ndef lshift(a,b):\n ''\n return a <<b\n__lshift__=lshift\n\ndef mod(a,b):\n ''\n return a %b\n__mod__=mod\n\ndef mul(a,b):\n ''\n return a *b\n__mul__=mul\n\ndef neg(a):\n ''\n return -a\n__neg__=neg\n\ndef or_(a,b):\n ''\n return a |b\n__or__=or_\n\ndef pos(a):\n ''\n return +a\n \n__pos__=pos\n\ndef pow(a,b):\n ''\n return a **b\n__pow__=pow\n\ndef rshift(a,b):\n ''\n return a >>b\n__rshift__=rshift\n\ndef sub(a,b):\n ''\n return a -b\n__sub__=sub\n\ndef truediv(a,b):\n ''\n return a /b\n__truediv__=truediv\n\ndef xor(a,b):\n ''\n return a ^b\n__xor__=xor\n\ndef concat(a,b):\n ''\n if not (hasattr(a,'__getitem__')and hasattr(b,'__getitem__')):\n  raise TypeError('a and b must be sequences')\n return a+b\n__concat__=concat\n\ndef contains(a,b):\n ''\n return b in a\n__contains__=contains\n\ndef countOf(a,b):\n ''\n count=0\n for i in a:\n  if i ==b:\n   count +=1\n return count\n \ndef delitem(a,b):\n ''\n del a[b]\n__delitem__=delitem\n\ndef getitem(a,b):\n ''\n return a[b]\n__getitem__=getitem\n\n\ndef indexOf(a,b):\n ''\n \n for i,j in enumerate(a):\n  if j ==b:\n   return i\n else :\n  raise ValueError('b not found in a')\n  \ndef setitem(a,b,c):\n ''\n a[b]=c\n__setitem__=setitem\n\n\n\nclass attrgetter:\n ''\n\n\n\n\n\n \n def __init__(self,attr,*attrs):\n  self. _attrs=(attr,)\n  self. _attrs +=attrs\n  if any(not isinstance(attr,str)for attr in self. _attrs):\n   raise TypeError('attribute name must be a string')\n   \n @staticmethod\n def _resolve_attr(obj,attr):\n  for name in attr. split('.'):\n  \n   obj=getattr(obj,name)\n  return obj\n  \n def __call__(self,obj):\n  if len(self. _attrs)==1:\n   return self. _resolve_attr(obj,self. _attrs[0])\n  return tuple(self. _resolve_attr(obj,attr)for attr in self. _attrs)\n  \nclass itemgetter:\n ''\n\n\n\n \n def __init__(self,item,*items):\n  self. _items=(item,)\n  self. _items +=items\n  \n def __call__(self,obj):\n  if len(self. _items)==1:\n   return obj[self. _items[0]]\n  return tuple(obj[item]for item in self. _items)\n  \nclass methodcaller:\n ''\n\n\n\n\n \n \n def __init__(self,name,*args,**kwargs):\n  self. _name=name\n  self. _args=args\n  self. _kwargs=kwargs\n  \n def __call__(self,obj):\n  return getattr(obj,self. _name)(*self. _args,**self. _kwargs)\n  \n  \ndef iadd(a,b):\n ''\n a +=b\n return a\n__iadd__=iadd\n\ndef iand(a,b):\n ''\n a &=b\n return a\n__iand__=iand\n\ndef iconcat(a,b):\n ''\n if not (hasattr(a,'__getitem__')and hasattr(b,'__getitem__')):\n  raise TypeError('a and b must be sequences')\n a +=b\n return a\n__iconcat__=iconcat\n\ndef ifloordiv(a,b):\n ''\n a //=b\n return a\n__ifloordiv__=ifloordiv\n\ndef ilshift(a,b):\n ''\n a <<=b\n return a\n__ilshift__=ilshift\n\ndef imod(a,b):\n ''\n a %=b\n return a\n__imod__=imod\n\ndef imul(a,b):\n ''\n a *=b\n return a\n__imul__=imul\n\ndef ior(a,b):\n ''\n a |=b\n return a\n__ior__=ior\n\ndef ipow(a,b):\n ''\n a **=b\n return a\n__ipow__=ipow\n\ndef irshift(a,b):\n ''\n a >>=b\n return a\n__irshift__=irshift\n\ndef isub(a,b):\n ''\n a -=b\n return a\n__isub__=isub\n\ndef itruediv(a,b):\n ''\n a /=b\n return a\n__itruediv__=itruediv\n\ndef ixor(a,b):\n ''\n a ^=b\n return a\n__ixor__=ixor\n\ndef length_hint(obj,default=0):\n ''\n\n\n\n\n\n\n \n try :\n  return len(obj)\n except TypeError:\n  try :\n   val=obj. __length_hint__()\n   if val is NotImplemented:\n    raise TypeError\n  except (AttributeError,TypeError):\n   return default\n  else :\n   if not val >0:\n    raise ValueError('default must be > 0')\n   return val\n   \n   \n   \n   \n   \n   \n"], "keyword": [".py", "#! /usr/bin/env python3\n\n\"\"\"Keywords (from \"graminit.c\")\n\nThis file is automatically generated; please don't muck it up!\n\nTo update the symbols in this file, 'cd' to the top directory of\nthe python source tree after building the interpreter and run:\n\n    ./python Lib/keyword.py\n\"\"\"\n\n__all__=[\"iskeyword\",\"kwlist\"]\n\nkwlist=[\n\n'False',\n'None',\n'True',\n'and',\n'as',\n'assert',\n'break',\n'class',\n'continue',\n'def',\n'del',\n'elif',\n'else',\n'except',\n'finally',\n'for',\n'from',\n'global',\n'if',\n'import',\n'in',\n'is',\n'lambda',\n'nonlocal',\n'not',\n'or',\n'pass',\n'raise',\n'return',\n'try',\n'while',\n'with',\n'yield',\n\n]\n\niskeyword=frozenset(kwlist). __contains__\n\ndef main():\n import sys,re\n \n args=sys. argv[1:]\n iptfile=args and args[0]or\"Python/graminit.c\"\n if len(args)>1:optfile=args[1]\n else :optfile=\"Lib/keyword.py\"\n \n \n with open(iptfile)as fp:\n  strprog=re. compile('\"([^\"]+)\"')\n  lines=[]\n  for line in fp:\n   if'{1, \"'in line:\n    match=strprog. search(line)\n    if match:\n     lines. append(\"        '\"+match. group(1)+\"',\\n\")\n lines. sort()\n \n \n with open(optfile)as fp:\n  format=fp. readlines()\n  \n  \n try :\n  start=format. index(\"#--start keywords--\\n\")+1\n  end=format. index(\"#--end keywords--\\n\")\n  format[start:end]=lines\n except ValueError:\n  sys. stderr. write(\"target does not contain format markers\\n\")\n  sys. exit(1)\n  \n  \n fp=open(optfile,'w')\n fp. write(''. join(format))\n fp. close()\n \nif __name__ ==\"__main__\":\n main()\n"], "re": [".py", "\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nr\"\"\"Support for regular expressions (RE).\n\nThis module provides regular expression matching operations similar to\nthose found in Perl.  It supports both 8-bit and Unicode strings; both\nthe pattern and the strings being processed can contain null bytes and\ncharacters outside the US ASCII range.\n\nRegular expressions can contain both special and ordinary characters.\nMost ordinary characters, like \"A\", \"a\", or \"0\", are the simplest\nregular expressions; they simply match themselves.  You can\nconcatenate ordinary characters, so last matches the string 'last'.\n\nThe special characters are:\n    \".\"      Matches any character except a newline.\n    \"^\"      Matches the start of the string.\n    \"$\"      Matches the end of the string or just before the newline at\n             the end of the string.\n    \"*\"      Matches 0 or more (greedy) repetitions of the preceding RE.\n             Greedy means that it will match as many repetitions as possible.\n    \"+\"      Matches 1 or more (greedy) repetitions of the preceding RE.\n    \"?\"      Matches 0 or 1 (greedy) of the preceding RE.\n    *?,+?,?? Non-greedy versions of the previous three special characters.\n    {m,n}    Matches from m to n repetitions of the preceding RE.\n    {m,n}?   Non-greedy version of the above.\n    \"\\\\\"     Either escapes special characters or signals a special sequence.\n    []       Indicates a set of characters.\n             A \"^\" as the first character indicates a complementing set.\n    \"|\"      A|B, creates an RE that will match either A or B.\n    (...)    Matches the RE inside the parentheses.\n             The contents can be retrieved or matched later in the string.\n    (?aiLmsux) Set the A, I, L, M, S, U, or X flag for the RE (see below).\n    (?:...)  Non-grouping version of regular parentheses.\n    (?P<name>...) The substring matched by the group is accessible by name.\n    (?P=name)     Matches the text matched earlier by the group named name.\n    (?#...)  A comment; ignored.\n    (?=...)  Matches if ... matches next, but doesn't consume the string.\n    (?!...)  Matches if ... doesn't match next.\n    (?<=...) Matches if preceded by ... (must be fixed length).\n    (?<!...) Matches if not preceded by ... (must be fixed length).\n    (?(id/name)yes|no) Matches yes pattern if the group with id/name matched,\n                       the (optional) no pattern otherwise.\n\nThe special sequences consist of \"\\\\\" and a character from the list\nbelow.  If the ordinary character is not on the list, then the\nresulting RE will match the second character.\n    \\number  Matches the contents of the group of the same number.\n    \\A       Matches only at the start of the string.\n    \\Z       Matches only at the end of the string.\n    \\b       Matches the empty string, but only at the start or end of a word.\n    \\B       Matches the empty string, but not at the start or end of a word.\n    \\d       Matches any decimal digit; equivalent to the set [0-9] in\n             bytes patterns or string patterns with the ASCII flag.\n             In string patterns without the ASCII flag, it will match the whole\n             range of Unicode digits.\n    \\D       Matches any non-digit character; equivalent to [^\\d].\n    \\s       Matches any whitespace character; equivalent to [ \\t\\n\\r\\f\\v] in\n             bytes patterns or string patterns with the ASCII flag.\n             In string patterns without the ASCII flag, it will match the whole\n             range of Unicode whitespace characters.\n    \\S       Matches any non-whitespace character; equivalent to [^\\s].\n    \\w       Matches any alphanumeric character; equivalent to [a-zA-Z0-9_]\n             in bytes patterns or string patterns with the ASCII flag.\n             In string patterns without the ASCII flag, it will match the\n             range of Unicode alphanumeric characters (letters plus digits\n             plus underscore).\n             With LOCALE, it will match the set [0-9_] plus characters defined\n             as letters for the current locale.\n    \\W       Matches the complement of \\w.\n    \\\\       Matches a literal backslash.\n\nThis module exports the following functions:\n    match    Match a regular expression pattern to the beginning of a string.\n    search   Search a string for the presence of a pattern.\n    sub      Substitute occurrences of a pattern found in a string.\n    subn     Same as sub, but also return the number of substitutions made.\n    split    Split a string by the occurrences of a pattern.\n    findall  Find all occurrences of a pattern in a string.\n    finditer Return an iterator yielding a match object for each match.\n    compile  Compile a pattern into a RegexObject.\n    purge    Clear the regular expression cache.\n    escape   Backslash all non-alphanumerics in a string.\n\nSome of the functions in this module takes flags as optional parameters:\n    A  ASCII       For string patterns, make \\w, \\W, \\b, \\B, \\d, \\D\n                   match the corresponding ASCII character categories\n                   (rather than the whole Unicode categories, which is the\n                   default).\n                   For bytes patterns, this flag is the only available\n                   behaviour and needn't be specified.\n    I  IGNORECASE  Perform case-insensitive matching.\n    L  LOCALE      Make \\w, \\W, \\b, \\B, dependent on the current locale.\n    M  MULTILINE   \"^\" matches the beginning of lines (after a newline)\n                   as well as the string.\n                   \"$\" matches the end of lines (before a newline) as well\n                   as the end of the string.\n    S  DOTALL      \".\" matches any character at all, including the newline.\n    X  VERBOSE     Ignore whitespace and comments for nicer looking RE's.\n    U  UNICODE     For compatibility only. Ignored for string patterns (it\n                   is the default), and forbidden for bytes patterns.\n\nThis module also defines an exception 'error'.\n\n\"\"\"\n\nimport sre_compile\nimport sre_parse\n\n\n__all__=[\"match\",\"search\",\"sub\",\"subn\",\"split\",\"findall\",\n\"compile\",\"purge\",\"template\",\"escape\",\"A\",\"I\",\"L\",\"M\",\"S\",\"X\",\n\"U\",\"ASCII\",\"IGNORECASE\",\"LOCALE\",\"MULTILINE\",\"DOTALL\",\"VERBOSE\",\n\"UNICODE\",\"error\"]\n\n__version__=\"2.2.1\"\n\n\nA=ASCII=sre_compile. SRE_FLAG_ASCII\nI=IGNORECASE=sre_compile. SRE_FLAG_IGNORECASE\nL=LOCALE=sre_compile. SRE_FLAG_LOCALE\nU=UNICODE=sre_compile. SRE_FLAG_UNICODE\nM=MULTILINE=sre_compile. SRE_FLAG_MULTILINE\nS=DOTALL=sre_compile. SRE_FLAG_DOTALL\nX=VERBOSE=sre_compile. SRE_FLAG_VERBOSE\n\n\nT=TEMPLATE=sre_compile. SRE_FLAG_TEMPLATE\nDEBUG=sre_compile. SRE_FLAG_DEBUG\n\n\nerror=sre_compile. error\n\n\n\n\ndef match(pattern,string,flags=0):\n ''\n \n return _compile(pattern,flags). match(string)\n \ndef search(pattern,string,flags=0):\n ''\n \n return _compile(pattern,flags). search(string)\n \ndef sub(pattern,repl,string,count=0,flags=0):\n ''\n\n\n\n\n \n return _compile(pattern,flags). sub(repl,string,count)\n \ndef subn(pattern,repl,string,count=0,flags=0):\n ''\n\n\n\n\n\n\n \n return _compile(pattern,flags). subn(repl,string,count)\n \ndef split(pattern,string,maxsplit=0,flags=0):\n ''\n\n\n\n\n\n \n return _compile(pattern,flags). split(string,maxsplit)\n \ndef findall(pattern,string,flags=0):\n ''\n\n\n\n\n\n \n return _compile(pattern,flags). findall(string)\n \ndef finditer(pattern,string,flags=0):\n ''\n\n\n \n return _compile(pattern,flags). finditer(string)\n \ndef compile(pattern,flags=0):\n ''\n \n return _compile(pattern,flags)\n \ndef purge():\n ''\n _cache. clear()\n _cache_repl. clear()\n \ndef template(pattern,flags=0):\n ''\n return _compile(pattern,flags |T)\n \n_alphanum_str=frozenset(\n\"_abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ01234567890\")\n_alphanum_bytes=frozenset(\nb\"_abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ01234567890\")\n\ndef escape(pattern):\n ''\n\n \n if isinstance(pattern,str):\n  alphanum=_alphanum_str\n  s=list(pattern)\n  for i,c in enumerate(pattern):\n   if c not in alphanum:\n    if c ==\"\\000\":\n     s[i]=\"\\\\000\"\n    else :\n     s[i]=\"\\\\\"+c\n  return\"\". join(s)\n else :\n  alphanum=_alphanum_bytes\n  s=[]\n  esc=ord(b\"\\\\\")\n  for c in pattern:\n   if c in alphanum:\n    s. append(c)\n   else :\n    if c ==0:\n     s. extend(b\"\\\\000\")\n    else :\n     s. append(esc)\n     s. append(c)\n  return bytes(s)\n  \n  \n  \n  \n_cache={}\n_cache_repl={}\n\n_pattern_type=type(sre_compile. compile(\"\",0))\n\n_MAXCACHE=512\ndef _compile(pattern,flags):\n\n try :\n \n \n  return _cache[\"%s:%s:%s\"%(type(pattern),pattern,flags)]\n except KeyError:\n  pass\n  \n if isinstance(pattern,_pattern_type):\n  if flags:\n   raise ValueError(\n   \"Cannot process flags argument with a compiled pattern\")\n  return pattern\n if not sre_compile. isstring(pattern):\n  raise TypeError(\"first argument must be string or compiled pattern\")\n p=sre_compile. compile(pattern,flags)\n \n if len(_cache)>=_MAXCACHE:\n  _cache. clear()\n  \n  \n _cache[\"%s:%s:%s\"%(type(pattern),pattern,flags)]=p\n return p\n \ndef _compile_repl(repl,pattern):\n\n try :\n \n \n  return _cache_repl[\"%s:%s\"%(repl,pattern)]\n except KeyError:\n  pass\n p=sre_parse. parse_template(repl,pattern)\n if len(_cache_repl)>=_MAXCACHE:\n  _cache_repl. clear()\n _cache_repl[\"%s:%s\"%(repl,pattern)]=p\n \n \n return p\n \ndef _expand(pattern,match,template):\n\n template=sre_parse. parse_template(template,pattern)\n return sre_parse. expand_template(template,match)\n \ndef _subx(pattern,template):\n\n template=_compile_repl(template,pattern)\n if not template[0]and len(template[1])==1:\n \n  return template[1][0]\n def filter(match,template=template):\n  return sre_parse. expand_template(template,match)\n return filter\n \n \n \nimport copyreg\n\ndef _pickle(p):\n return _compile,(p. pattern,p. flags)\n \ncopyreg. pickle(_pattern_type,_pickle,_compile)\n\n\n\n\nclass Scanner:\n def __init__(self,lexicon,flags=0):\n  from sre_constants import BRANCH,SUBPATTERN\n  self. lexicon=lexicon\n  \n  p=[]\n  s=sre_parse. Pattern()\n  s. flags=flags\n  for phrase,action in lexicon:\n   p. append(sre_parse. SubPattern(s,[\n   (SUBPATTERN,(len(p)+1,sre_parse. parse(phrase,flags))),\n   ]))\n  s. groups=len(p)+1\n  p=sre_parse. SubPattern(s,[(BRANCH,(None ,p))])\n  self. scanner=sre_compile. compile(p)\n def scan(self,string):\n  result=[]\n  append=result. append\n  match=self. scanner. scanner(string). match\n  i=0\n  while 1:\n   m=match()\n   if not m:\n    break\n   j=m. end()\n   if i ==j:\n    break\n   action=self. lexicon[m. lastindex -1][1]\n   if callable(action):\n    self. match=m\n    action=action(self,m. group())\n   if action is not None :\n    append(action)\n   i=j\n  return result,string[i:]\n"], "browser": [".py", "import javascript\n\nfrom _browser import *\n\nfrom . local_storage import LocalStorage\nfrom . session_storage import SessionStorage\nfrom . object_storage import ObjectStorage\n\nWebSocket=window. WebSocket. new", 1], "copyreg": [".py", "''\n\n\n\n\n\n__all__=[\"pickle\",\"constructor\",\n\"add_extension\",\"remove_extension\",\"clear_extension_cache\"]\n\ndispatch_table={}\n\ndef pickle(ob_type,pickle_function,constructor_ob=None ):\n if not callable(pickle_function):\n  raise TypeError(\"reduction functions must be callable\")\n dispatch_table[ob_type]=pickle_function\n \n \n \n if constructor_ob is not None :\n  constructor(constructor_ob)\n  \ndef constructor(object):\n if not callable(object):\n  raise TypeError(\"constructors must be callable\")\n  \n  \n  \ntry :\n complex\nexcept NameError:\n pass\nelse :\n\n def pickle_complex(c):\n  return complex,(c. real,c. imag)\n  \n pickle(complex,pickle_complex,complex)\n \n \n \ndef _reconstructor(cls,base,state):\n if base is object:\n  obj=object. __new__(cls)\n else :\n  obj=base. __new__(cls,state)\n  if base. __init__ !=object. __init__:\n   base. __init__(obj,state)\n return obj\n \n_HEAPTYPE=1 <<9\n\n\n\ndef _reduce_ex(self,proto):\n assert proto <2\n for base in self. __class__. __mro__:\n  if hasattr(base,'__flags__')and not base. __flags__&_HEAPTYPE:\n   break\n else :\n  base=object\n if base is object:\n  state=None\n else :\n  if base is self. __class__:\n   raise TypeError(\"can't pickle %s objects\"%base. __name__)\n  state=base(self)\n args=(self. __class__,base,state)\n try :\n  getstate=self. __getstate__\n except AttributeError:\n  if getattr(self,\"__slots__\",None ):\n   raise TypeError(\"a class that defines __slots__ without \"\n   \"defining __getstate__ cannot be pickled\")\n  try :\n   dict=self. __dict__\n  except AttributeError:\n   dict=None\n else :\n  dict=getstate()\n if dict:\n  return _reconstructor,args,dict\n else :\n  return _reconstructor,args\n  \n  \n  \ndef __newobj__(cls,*args):\n return cls. __new__(cls,*args)\n \ndef _slotnames(cls):\n ''\n\n\n\n\n\n\n\n \n \n \n names=cls. __dict__. get(\"__slotnames__\")\n if names is not None :\n  return names\n  \n  \n names=[]\n if not hasattr(cls,\"__slots__\"):\n \n  pass\n else :\n \n  for c in cls. __mro__:\n   if\"__slots__\"in c. __dict__:\n    slots=c. __dict__['__slots__']\n    \n    if isinstance(slots,str):\n     slots=(slots,)\n    for name in slots:\n    \n     if name in (\"__dict__\",\"__weakref__\"):\n      continue\n      \n     elif name. startswith('__')and not name. endswith('__'):\n      names. append('_%s%s'%(c. __name__,name))\n     else :\n      names. append(name)\n      \n      \n try :\n  cls. __slotnames__=names\n except :\n  pass\n  \n return names\n \n \n \n \n \n \n \n \n \n \n_extension_registry={}\n_inverted_registry={}\n_extension_cache={}\n\n\n\ndef add_extension(module,name,code):\n ''\n code=int(code)\n if not 1 <=code <=0x7fffffff:\n  raise ValueError(\"code out of range\")\n key=(module,name)\n if (_extension_registry. get(key)==code and\n _inverted_registry. get(code)==key):\n  return\n if key in _extension_registry:\n  raise ValueError(\"key %s is already registered with code %s\"%\n  (key,_extension_registry[key]))\n if code in _inverted_registry:\n  raise ValueError(\"code %s is already in use for key %s\"%\n  (code,_inverted_registry[code]))\n _extension_registry[key]=code\n _inverted_registry[code]=key\n \ndef remove_extension(module,name,code):\n ''\n key=(module,name)\n if (_extension_registry. get(key)!=code or\n _inverted_registry. get(code)!=key):\n  raise ValueError(\"key %s is not registered with code %s\"%\n  (key,code))\n del _extension_registry[key]\n del _inverted_registry[code]\n if code in _extension_cache:\n  del _extension_cache[code]\n  \ndef clear_extension_cache():\n _extension_cache. clear()\n \n \n \n \n \n \n \n \n \n \n \n \n \n"], "sys": [".py", "\nfrom _sys import *\n\n_getframe=Getframe\nfrom javascript import JSObject\nfrom browser import window\n\nbrython_debug_mode=__BRYTHON__. debug\n\nbase_exec_prefix=__BRYTHON__. brython_path\n\nbase_prefix=__BRYTHON__. brython_path\n\nbuiltin_module_names=__BRYTHON__. builtin_module_names\n\nbyteorder='little'\n\ndef exc_info():\n exc=__BRYTHON__. current_exception\n if exc is None :\n  return (None ,None ,None )\n return (exc. __class__,exc,exc. traceback)\n \nexec_prefix=__BRYTHON__. brython_path\n\nexecutable=__BRYTHON__. brython_path+'/brython.js'\n\nargv=__BRYTHON__. __ARGV\n\ndef exit(i=None ):\n raise SystemExit('')\n \nclass flag_class:\n def __init__(self):\n  self. debug=0\n  self. inspect=0\n  self. interactive=0\n  self. optimize=0\n  self. dont_write_bytecode=0\n  self. no_user_site=0\n  self. no_site=0\n  self. ignore_environment=0\n  self. verbose=0\n  self. bytes_warning=0\n  self. quiet=0\n  self. hash_randomization=1\n  \nflags=flag_class()\n\nclass float_info:\n mant_dig=53\n max=window. Number. MAX_VALUE\n min=window. Number. MIN_VALUE\n radix=2\n \ndef getfilesystemencoding(*args,**kw):\n ''\n\n \n return'utf-8'\n \ndef getrecursionlimit():\n return 200\n \nmaxsize=2 **63 -1\n\nmaxunicode=1114111\n\n\n\n\n\n\nplatform=\"brython\"\n\nprefix=__BRYTHON__. brython_path\n\nversion='.'. join(str(x)for x in __BRYTHON__. version_info[:3])\nversion +=\" (default, %s) \\n[Javascript 1.5] on Brython\"%__BRYTHON__. compiled_date\nhexversion=0x03000000\n\nclass _version_info(object):\n def __init__(self,version_info):\n  self. version_info=version_info\n  self. major=version_info[0]\n  self. minor=version_info[1]\n  self. micro=version_info[2]\n  self. releaselevel=version_info[3]\n  self. serial=version_info[4]\n  \n def __getitem__(self,index):\n  if isinstance(self. version_info[index],list):\n   return tuple(self. version_info[index])\n  return self. version_info[index]\n  \n def hexversion(self):\n  try :\n   return'0%d0%d0%d'%(self. major,self. minor,self. micro)\n  finally :\n   return'0%d0000'%(self. major)\n   \n def __str__(self):\n  _s=\"sys.version(major=%d, minor=%d, micro=%d, releaselevel='%s', serial=%d)\"\n  return _s %(self. major,self. minor,self. micro,\n  self. releaselevel,self. serial)\n  \n  \n def __eq__(self,other):\n  if isinstance(other,tuple):\n   return (self. major,self. minor,self. micro)==other\n   \n  raise Error(\"Error! I don't know how to compare!\")\n  \n def __ge__(self,other):\n  if isinstance(other,tuple):\n   return (self. major,self. minor,self. micro)>=other\n   \n  raise Error(\"Error! I don't know how to compare!\")\n  \n def __gt__(self,other):\n  if isinstance(other,tuple):\n   return (self. major,self. minor,self. micro)>other\n   \n  raise Error(\"Error! I don't know how to compare!\")\n  \n def __le__(self,other):\n  if isinstance(other,tuple):\n   return (self. major,self. minor,self. micro)<=other\n   \n  raise Error(\"Error! I don't know how to compare!\")\n  \n def __lt__(self,other):\n  if isinstance(other,tuple):\n   return (self. major,self. minor,self. micro)<other\n   \n  raise Error(\"Error! I don't know how to compare!\")\n  \n def __ne__(self,other):\n  if isinstance(other,tuple):\n   return (self. major,self. minor,self. micro)!=other\n   \n  raise Error(\"Error! I don't know how to compare!\")\n  \n  \n  \nversion_info=_version_info(__BRYTHON__. version_info)\n\nclass _implementation:\n def __init__(self):\n  self. name='brython'\n  self. version=_version_info(__BRYTHON__. implementation)\n  self. hexversion=self. version. hexversion()\n  self. cache_tag=None\n  \n def __repr__(self):\n  return\"namespace(name='%s' version=%s hexversion='%s')\"%(self. name,self. version,self. hexversion)\n  \n def __str__(self):\n  return\"namespace(name='%s' version=%s hexversion='%s')\"%(self. name,self. version,self. hexversion)\n  \nimplementation=_implementation()\n\nclass _hash_info:\n def __init__(self):\n  self. width=32,\n  self. modulus=2147483647\n  self. inf=314159\n  self. nan=0\n  self. imag=1000003\n  self. algorithm='siphash24'\n  self. hash_bits=64\n  self. seed_bits=128\n  cutoff=0\n  \n def __repr__(self):\n \n  return\"sys.hash_info(width=32, modulus=2147483647, inf=314159, nan=0, imag=1000003, algorithm='siphash24', hash_bits=64, seed_bits=128, cutoff=0)\"\n  \nhash_info=_hash_info()\n\nclass _float_info:\n ''\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n \n def __init__(self):\n  _number=window. Number\n  self. dig=15\n  self. epsilon=2 **-52\n  self. mant_dig=53\n  self. max=_number. MAX_VALUE\n  self. max_exp=2 **10\n  self. max_10_exp=308\n  self. min=2 **(-1022)\n  self. min_exp=-1021\n  self. min_10_exp=-307\n  self. radix=2\n  self. rounds=1\n  self. _tuple=(self. max,self. max_exp,self. max_10_exp,self. min,self. min_exp,self. min_10_exp,self. dig,self. mant_dig,self. epsilon,self. radix,self. rounds)\n  \n def __getitem__(self,k):\n  return self. _tuple[k]\n  \n def __iter__(self):\n  return iter(self. _tuple)\n  \nfloat_info=_float_info()\n\nwarnoptions=[]\n\ndef getfilesystemencoding():\n return'utf-8'\n \n \n__stdout__=__BRYTHON__. stdout\n__stderr__=__BRYTHON__. stderr\n__stdin__=__BRYTHON__. stdin\n\n\ndel JSObject\ndel _implementation\n"], "sre_parse": [".py", "\n\n\n\n\n\n\n\n\n\n\"\"\"Internal support module for sre\"\"\"\n\n\n\nimport sys\n\nfrom sre_constants import *\nfrom _sre import MAXREPEAT\n\nSPECIAL_CHARS=\".\\\\[{()*+?^$|\"\nREPEAT_CHARS=\"*+?{\"\n\nDIGITS=set(\"0123456789\")\n\nOCTDIGITS=set(\"01234567\")\nHEXDIGITS=set(\"0123456789abcdefABCDEF\")\n\nWHITESPACE=set(\" \\t\\n\\r\\v\\f\")\n\nESCAPES={\nr\"\\a\":(LITERAL,ord(\"\\a\")),\nr\"\\b\":(LITERAL,ord(\"\\b\")),\nr\"\\f\":(LITERAL,ord(\"\\f\")),\nr\"\\n\":(LITERAL,ord(\"\\n\")),\nr\"\\r\":(LITERAL,ord(\"\\r\")),\nr\"\\t\":(LITERAL,ord(\"\\t\")),\nr\"\\v\":(LITERAL,ord(\"\\v\")),\nr\"\\\\\":(LITERAL,ord(\"\\\\\"))\n}\n\nCATEGORIES={\nr\"\\A\":(AT,AT_BEGINNING_STRING),\nr\"\\b\":(AT,AT_BOUNDARY),\nr\"\\B\":(AT,AT_NON_BOUNDARY),\nr\"\\d\":(IN,[(CATEGORY,CATEGORY_DIGIT)]),\nr\"\\D\":(IN,[(CATEGORY,CATEGORY_NOT_DIGIT)]),\nr\"\\s\":(IN,[(CATEGORY,CATEGORY_SPACE)]),\nr\"\\S\":(IN,[(CATEGORY,CATEGORY_NOT_SPACE)]),\nr\"\\w\":(IN,[(CATEGORY,CATEGORY_WORD)]),\nr\"\\W\":(IN,[(CATEGORY,CATEGORY_NOT_WORD)]),\nr\"\\Z\":(AT,AT_END_STRING),\n}\n\nFLAGS={\n\n\"i\":SRE_FLAG_IGNORECASE,\n\"L\":SRE_FLAG_LOCALE,\n\"m\":SRE_FLAG_MULTILINE,\n\"s\":SRE_FLAG_DOTALL,\n\"x\":SRE_FLAG_VERBOSE,\n\n\"a\":SRE_FLAG_ASCII,\n\"t\":SRE_FLAG_TEMPLATE,\n\"u\":SRE_FLAG_UNICODE,\n}\n\nclass Pattern:\n\n def __init__(self):\n  self. flags=0\n  self. open=[]\n  self. groups=1\n  self. groupdict={}\n def opengroup(self,name=None ):\n  gid=self. groups\n  self. groups=gid+1\n  if name is not None :\n   ogid=self. groupdict. get(name,None )\n   if ogid is not None :\n    raise error(\"redefinition of group name %s as group %d; \"\n    \"was group %d\"%(repr(name),gid,ogid))\n   self. groupdict[name]=gid\n  self. open. append(gid)\n  return gid\n def closegroup(self,gid):\n  self. open. remove(gid)\n def checkgroup(self,gid):\n  return gid <self. groups and gid not in self. open\n  \nclass SubPattern:\n\n def __init__(self,pattern,data=None ):\n  self. pattern=pattern\n  if data is None :\n   data=[]\n  self. data=data\n  self. width=None\n def __iter__(self):\n  return iter(self. data)\n  \n def dump(self,level=0):\n  nl=1\n  seqtypes=(tuple,list)\n  for op,av in self. data:\n   print(level *\"  \"+op,end=' ');nl=0\n   if op ==\"in\":\n   \n    print();nl=1\n    for op,a in av:\n     print((level+1)*\"  \"+op,a)\n   elif op ==\"branch\":\n    print();nl=1\n    i=0\n    for a in av[1]:\n     if i >0:\n      print(level *\"  \"+\"or\")\n     a. dump(level+1);nl=1\n     i=i+1\n   elif isinstance(av,seqtypes):\n    for a in av:\n     if isinstance(a,SubPattern):\n      if not nl:print()\n      a. dump(level+1);nl=1\n     else :\n      print(a,end=' ');nl=0\n   else :\n    print(av,end=' ');nl=0\n   if not nl:print()\n def __repr__(self):\n  return repr(self. data)\n def __len__(self):\n  return len(self. data)\n def __delitem__(self,index):\n  del self. data[index]\n def __getitem__(self,index):\n  if isinstance(index,slice):\n   return SubPattern(self. pattern,self. data[index])\n  return self. data[index]\n def __setitem__(self,index,code):\n  self. data[index]=code\n def insert(self,index,code):\n  self. data. insert(index,code)\n def append(self,code):\n  self. data. append(code)\n def getwidth(self):\n \n  if self. width:\n   return self. width\n  lo=hi=0\n  UNITCODES=(ANY,RANGE,IN,LITERAL,NOT_LITERAL,CATEGORY)\n  REPEATCODES=(MIN_REPEAT,MAX_REPEAT)\n  for op,av in self. data:\n   if op is BRANCH:\n    i=sys. maxsize\n    j=0\n    for av in av[1]:\n     l,h=av. getwidth()\n     i=min(i,l)\n     j=max(j,h)\n    lo=lo+i\n    hi=hi+j\n   elif op is CALL:\n    i,j=av. getwidth()\n    lo=lo+i\n    hi=hi+j\n   elif op is SUBPATTERN:\n    i,j=av[1]. getwidth()\n    lo=lo+i\n    hi=hi+j\n   elif op in REPEATCODES:\n    i,j=av[2]. getwidth()\n    lo=lo+int(i)*av[0]\n    hi=hi+int(j)*av[1]\n   elif op in UNITCODES:\n    lo=lo+1\n    hi=hi+1\n   elif op ==SUCCESS:\n    break\n  self. width=int(min(lo,sys. maxsize)),int(min(hi,sys. maxsize))\n  return self. width\n  \nclass Tokenizer:\n def __init__(self,string):\n  self. istext=isinstance(string,str)\n  self. string=string\n  self. index=0\n  self. __next()\n def __next(self):\n  if self. index >=len(self. string):\n   self. next=None\n   return\n  char=self. string[self. index:self. index+1]\n  \n  \n  if char and not self. istext:\n   char=chr(char[0])\n  if char ==\"\\\\\":\n   try :\n    c=self. string[self. index+1]\n   except IndexError:\n    raise error(\"bogus escape (end of line)\")\n   if not self. istext:\n    c=chr(c)\n   char=char+c\n  self. index=self. index+len(char)\n  self. next=char\n def match(self,char,skip=1):\n  if char ==self. next:\n   if skip:\n    self. __next()\n   return 1\n  return 0\n def get(self):\n  this=self. next\n  self. __next()\n  return this\n def getwhile(self,n,charset):\n  result=''\n  for _ in range(n):\n   c=self. next\n   if c not in charset:\n    break\n   result +=c\n   self. __next()\n  return result\n def tell(self):\n  return self. index,self. next\n def seek(self,index):\n  self. index,self. next=index\n  \ndef isident(char):\n return\"a\"<=char <=\"z\"or\"A\"<=char <=\"Z\"or char ==\"_\"\n \ndef isdigit(char):\n return\"0\"<=char <=\"9\"\n \ndef isname(name):\n\n if not isident(name[0]):\n  return False\n for char in name[1:]:\n  if not isident(char)and not isdigit(char):\n   return False\n return True\n \ndef _class_escape(source,escape):\n\n code=ESCAPES. get(escape)\n if code:\n  return code\n code=CATEGORIES. get(escape)\n if code and code[0]==IN:\n  return code\n try :\n  c=escape[1:2]\n  if c ==\"x\":\n  \n   escape +=source. getwhile(2,HEXDIGITS)\n   if len(escape)!=4:\n    raise ValueError\n   return LITERAL,int(escape[2:],16)&0xff\n  elif c ==\"u\"and source. istext:\n  \n   escape +=source. getwhile(4,HEXDIGITS)\n   if len(escape)!=6:\n    raise ValueError\n   return LITERAL,int(escape[2:],16)\n  elif c ==\"U\"and source. istext:\n  \n   escape +=source. getwhile(8,HEXDIGITS)\n   if len(escape)!=10:\n    raise ValueError\n   c=int(escape[2:],16)\n   chr(c)\n   return LITERAL,c\n  elif c in OCTDIGITS:\n  \n   escape +=source. getwhile(2,OCTDIGITS)\n   return LITERAL,int(escape[1:],8)&0xff\n  elif c in DIGITS:\n   raise ValueError\n  if len(escape)==2:\n   return LITERAL,ord(escape[1])\n except ValueError:\n  pass\n raise error(\"bogus escape: %s\"%repr(escape))\n \ndef _escape(source,escape,state):\n\n code=CATEGORIES. get(escape)\n if code:\n  return code\n code=ESCAPES. get(escape)\n if code:\n  return code\n try :\n  c=escape[1:2]\n  if c ==\"x\":\n  \n   escape +=source. getwhile(2,HEXDIGITS)\n   if len(escape)!=4:\n    raise ValueError\n   return LITERAL,int(escape[2:],16)&0xff\n  elif c ==\"u\"and source. istext:\n  \n   escape +=source. getwhile(4,HEXDIGITS)\n   if len(escape)!=6:\n    raise ValueError\n   return LITERAL,int(escape[2:],16)\n  elif c ==\"U\"and source. istext:\n  \n   escape +=source. getwhile(8,HEXDIGITS)\n   if len(escape)!=10:\n    raise ValueError\n   c=int(escape[2:],16)\n   chr(c)\n   return LITERAL,c\n  elif c ==\"0\":\n  \n   escape +=source. getwhile(2,OCTDIGITS)\n   return LITERAL,int(escape[1:],8)&0xff\n  elif c in DIGITS:\n  \n   if source. next in DIGITS:\n    escape=escape+source. get()\n    if (escape[1]in OCTDIGITS and escape[2]in OCTDIGITS and\n    source. next in OCTDIGITS):\n    \n     escape=escape+source. get()\n     return LITERAL,int(escape[1:],8)&0xff\n     \n   group=int(escape[1:])\n   if group <state. groups:\n    if not state. checkgroup(group):\n     raise error(\"cannot refer to open group\")\n    return GROUPREF,group\n   raise ValueError\n  if len(escape)==2:\n   return LITERAL,ord(escape[1])\n except ValueError:\n  pass\n raise error(\"bogus escape: %s\"%repr(escape))\n \ndef _parse_sub(source,state,nested=1):\n\n\n items=[]\n itemsappend=items. append\n sourcematch=source. match\n while 1:\n  itemsappend(_parse(source,state))\n  if sourcematch(\"|\"):\n   continue\n  if not nested:\n   break\n  if not source. next or sourcematch(\")\",0):\n   break\n  else :\n   raise error(\"pattern not properly closed\")\n   \n if len(items)==1:\n  return items[0]\n  \n subpattern=SubPattern(state)\n subpatternappend=subpattern. append\n \n \n while 1:\n  prefix=None\n  for item in items:\n   if not item:\n    break\n   if prefix is None :\n    prefix=item[0]\n   elif item[0]!=prefix:\n    break\n  else :\n  \n  \n   for item in items:\n    del item[0]\n   subpatternappend(prefix)\n   continue\n  break\n  \n  \n for item in items:\n  if len(item)!=1 or item[0][0]!=LITERAL:\n   break\n else :\n \n \n  set=[]\n  setappend=set. append\n  for item in items:\n   setappend(item[0])\n  subpatternappend((IN,set))\n  return subpattern\n  \n subpattern. append((BRANCH,(None ,items)))\n return subpattern\n \ndef _parse_sub_cond(source,state,condgroup):\n item_yes=_parse(source,state)\n if source. match(\"|\"):\n  item_no=_parse(source,state)\n  if source. match(\"|\"):\n   raise error(\"conditional backref with more than two branches\")\n else :\n  item_no=None\n if source. next and not source. match(\")\",0):\n  raise error(\"pattern not properly closed\")\n subpattern=SubPattern(state)\n subpattern. append((GROUPREF_EXISTS,(condgroup,item_yes,item_no)))\n return subpattern\n \n_PATTERNENDERS=set(\"|)\")\n_ASSERTCHARS=set(\"=!<\")\n_LOOKBEHINDASSERTCHARS=set(\"=!\")\n_REPEATCODES=set([MIN_REPEAT,MAX_REPEAT])\n\ndef _parse(source,state):\n\n subpattern=SubPattern(state)\n \n \n subpatternappend=subpattern. append\n sourceget=source. get\n sourcematch=source. match\n _len=len\n PATTERNENDERS=_PATTERNENDERS\n ASSERTCHARS=_ASSERTCHARS\n LOOKBEHINDASSERTCHARS=_LOOKBEHINDASSERTCHARS\n REPEATCODES=_REPEATCODES\n \n while 1:\n \n  if source. next in PATTERNENDERS:\n   break\n  this=sourceget()\n  if this is None :\n   break\n   \n  if state. flags&SRE_FLAG_VERBOSE:\n  \n   if this in WHITESPACE:\n    continue\n   if this ==\"#\":\n    while 1:\n     this=sourceget()\n     if this in (None ,\"\\n\"):\n      break\n    continue\n    \n  if this and this[0]not in SPECIAL_CHARS:\n   subpatternappend((LITERAL,ord(this)))\n   \n  elif this ==\"[\":\n  \n   set=[]\n   setappend=set. append\n   \n   \n   if sourcematch(\"^\"):\n    setappend((NEGATE,None ))\n    \n   start=set[:]\n   while 1:\n    this=sourceget()\n    if this ==\"]\"and set !=start:\n     break\n    elif this and this[0]==\"\\\\\":\n     code1=_class_escape(source,this)\n    elif this:\n     code1=LITERAL,ord(this)\n    else :\n     raise error(\"unexpected end of regular expression\")\n    if sourcematch(\"-\"):\n    \n     this=sourceget()\n     if this ==\"]\":\n      if code1[0]is IN:\n       code1=code1[1][0]\n      setappend(code1)\n      setappend((LITERAL,ord(\"-\")))\n      break\n     elif this:\n      if this[0]==\"\\\\\":\n       code2=_class_escape(source,this)\n      else :\n       code2=LITERAL,ord(this)\n      if code1[0]!=LITERAL or code2[0]!=LITERAL:\n       raise error(\"bad character range\")\n      lo=code1[1]\n      hi=code2[1]\n      if hi <lo:\n       raise error(\"bad character range\")\n      setappend((RANGE,(lo,hi)))\n     else :\n      raise error(\"unexpected end of regular expression\")\n    else :\n     if code1[0]is IN:\n      code1=code1[1][0]\n     setappend(code1)\n     \n     \n   if _len(set)==1 and set[0][0]is LITERAL:\n    subpatternappend(set[0])\n   elif _len(set)==2 and set[0][0]is NEGATE and set[1][0]is LITERAL:\n    subpatternappend((NOT_LITERAL,set[1][1]))\n   else :\n   \n    subpatternappend((IN,set))\n    \n  elif this and this[0]in REPEAT_CHARS:\n  \n   if this ==\"?\":\n    min,max=0,1\n   elif this ==\"*\":\n    min,max=0,MAXREPEAT\n    \n   elif this ==\"+\":\n    min,max=1,MAXREPEAT\n   elif this ==\"{\":\n    if source. next ==\"}\":\n     subpatternappend((LITERAL,ord(this)))\n     continue\n    here=source. tell()\n    min,max=0,MAXREPEAT\n    lo=hi=\"\"\n    while source. next in DIGITS:\n     lo=lo+source. get()\n    if sourcematch(\",\"):\n     while source. next in DIGITS:\n      hi=hi+sourceget()\n    else :\n     hi=lo\n    if not sourcematch(\"}\"):\n     subpatternappend((LITERAL,ord(this)))\n     source. seek(here)\n     continue\n    if lo:\n     min=int(lo)\n     if min >=MAXREPEAT:\n      raise OverflowError(\"the repetition number is too large\")\n    if hi:\n     max=int(hi)\n     if max >=MAXREPEAT:\n      raise OverflowError(\"the repetition number is too large\")\n     if max <min:\n      raise error(\"bad repeat interval\")\n   else :\n    raise error(\"not supported\")\n    \n   if subpattern:\n    item=subpattern[-1:]\n   else :\n    item=None\n   if not item or (_len(item)==1 and item[0][0]==AT):\n    raise error(\"nothing to repeat\")\n   if item[0][0]in REPEATCODES:\n    raise error(\"multiple repeat\")\n   if sourcematch(\"?\"):\n    subpattern[-1]=(MIN_REPEAT,(min,max,item))\n   else :\n    subpattern[-1]=(MAX_REPEAT,(min,max,item))\n    \n  elif this ==\".\":\n   subpatternappend((ANY,None ))\n   \n  elif this ==\"(\":\n   group=1\n   name=None\n   condgroup=None\n   if sourcematch(\"?\"):\n    group=0\n    \n    if sourcematch(\"P\"):\n    \n     if sourcematch(\"<\"):\n     \n      name=\"\"\n      while 1:\n       char=sourceget()\n       if char is None :\n        raise error(\"unterminated name\")\n       if char ==\">\":\n        break\n       name=name+char\n      group=1\n      if not name:\n       raise error(\"missing group name\")\n      if not isname(name):\n       raise error(\"bad character in group name\")\n     elif sourcematch(\"=\"):\n     \n      name=\"\"\n      while 1:\n       char=sourceget()\n       if char is None :\n        raise error(\"unterminated name\")\n       if char ==\")\":\n        break\n       name=name+char\n      if not name:\n       raise error(\"missing group name\")\n      if not isname(name):\n       raise error(\"bad character in group name\")\n      gid=state. groupdict. get(name)\n      if gid is None :\n       raise error(\"unknown group name\")\n      subpatternappend((GROUPREF,gid))\n      continue\n     else :\n      char=sourceget()\n      if char is None :\n       raise error(\"unexpected end of pattern\")\n      raise error(\"unknown specifier: ?P%s\"%char)\n    elif sourcematch(\":\"):\n    \n     group=2\n    elif sourcematch(\"#\"):\n    \n     while 1:\n      if source. next is None or source. next ==\")\":\n       break\n      sourceget()\n     if not sourcematch(\")\"):\n      raise error(\"unbalanced parenthesis\")\n     continue\n    elif source. next in ASSERTCHARS:\n    \n     char=sourceget()\n     dir=1\n     if char ==\"<\":\n      if source. next not in LOOKBEHINDASSERTCHARS:\n       raise error(\"syntax error\")\n      dir=-1\n      char=sourceget()\n     p=_parse_sub(source,state)\n     if not sourcematch(\")\"):\n      raise error(\"unbalanced parenthesis\")\n     if char ==\"=\":\n      subpatternappend((ASSERT,(dir,p)))\n     else :\n      subpatternappend((ASSERT_NOT,(dir,p)))\n     continue\n    elif sourcematch(\"(\"):\n    \n     condname=\"\"\n     while 1:\n      char=sourceget()\n      if char is None :\n       raise error(\"unterminated name\")\n      if char ==\")\":\n       break\n      condname=condname+char\n     group=2\n     if not condname:\n      raise error(\"missing group name\")\n     if isname(condname):\n      condgroup=state. groupdict. get(condname)\n      if condgroup is None :\n       raise error(\"unknown group name\")\n     else :\n      try :\n       condgroup=int(condname)\n      except ValueError:\n       raise error(\"bad character in group name\")\n    else :\n    \n     if not source. next in FLAGS:\n      raise error(\"unexpected end of pattern\")\n     while source. next in FLAGS:\n      state. flags=state. flags |FLAGS[sourceget()]\n   if group:\n   \n    if group ==2:\n    \n     group=None\n    else :\n     group=state. opengroup(name)\n    if condgroup:\n     p=_parse_sub_cond(source,state,condgroup)\n    else :\n     p=_parse_sub(source,state)\n    if not sourcematch(\")\"):\n     raise error(\"unbalanced parenthesis\")\n    if group is not None :\n     state. closegroup(group)\n    subpatternappend((SUBPATTERN,(group,p)))\n   else :\n    while 1:\n     char=sourceget()\n     if char is None :\n      raise error(\"unexpected end of pattern\")\n     if char ==\")\":\n      break\n     raise error(\"unknown extension\")\n     \n  elif this ==\"^\":\n   subpatternappend((AT,AT_BEGINNING))\n   \n  elif this ==\"$\":\n   subpattern. append((AT,AT_END))\n   \n  elif this and this[0]==\"\\\\\":\n   code=_escape(source,this,state)\n   subpatternappend(code)\n   \n  else :\n   raise error(\"parser error\")\n   \n return subpattern\n \ndef fix_flags(src,flags):\n\n if isinstance(src,str):\n  if not flags&SRE_FLAG_ASCII:\n   flags |=SRE_FLAG_UNICODE\n  elif flags&SRE_FLAG_UNICODE:\n   raise ValueError(\"ASCII and UNICODE flags are incompatible\")\n else :\n  if flags&SRE_FLAG_UNICODE:\n   raise ValueError(\"can't use UNICODE flag with a bytes pattern\")\n return flags\n \ndef parse(str,flags=0,pattern=None ):\n\n source=Tokenizer(str)\n \n if pattern is None :\n  pattern=Pattern()\n pattern. flags=flags\n pattern. str=str\n p=_parse_sub(source,pattern,0)\n p. pattern. flags=fix_flags(str,p. pattern. flags)\n \n tail=source. get()\n if tail ==\")\":\n  raise error(\"unbalanced parenthesis\")\n elif tail:\n  raise error(\"bogus characters at end of regular expression\")\n  \n if flags&SRE_FLAG_DEBUG:\n  p. dump()\n  \n if not (flags&SRE_FLAG_VERBOSE)and p. pattern. flags&SRE_FLAG_VERBOSE:\n \n \n  return parse(str,p. pattern. flags)\n  \n return p\n \ndef parse_template(source,pattern):\n\n\n s=Tokenizer(source)\n sget=s. get\n p=[]\n a=p. append\n def literal(literal,p=p,pappend=a):\n  if p and p[-1][0]is LITERAL:\n   p[-1]=LITERAL,p[-1][1]+literal\n  else :\n   pappend((LITERAL,literal))\n sep=source[:0]\n if isinstance(sep,str):\n  makechar=chr\n else :\n  makechar=chr\n while 1:\n  this=sget()\n  if this is None :\n   break\n  if this and this[0]==\"\\\\\":\n  \n   c=this[1:2]\n   if c ==\"g\":\n    name=\"\"\n    if s. match(\"<\"):\n     while 1:\n      char=sget()\n      if char is None :\n       raise error(\"unterminated group name\")\n      if char ==\">\":\n       break\n      name=name+char\n    if not name:\n     raise error(\"missing group name\")\n    try :\n     index=int(name)\n     if index <0:\n      raise error(\"negative group number\")\n    except ValueError:\n     if not isname(name):\n      raise error(\"bad character in group name\")\n     try :\n      index=pattern. groupindex[name]\n     except KeyError:\n      raise IndexError(\"unknown group name\")\n    a((MARK,index))\n   elif c ==\"0\":\n    if s. next in OCTDIGITS:\n     this=this+sget()\n     if s. next in OCTDIGITS:\n      this=this+sget()\n    literal(makechar(int(this[1:],8)&0xff))\n   elif c in DIGITS:\n    isoctal=False\n    if s. next in DIGITS:\n     this=this+sget()\n     if (c in OCTDIGITS and this[2]in OCTDIGITS and\n     s. next in OCTDIGITS):\n      this=this+sget()\n      isoctal=True\n      literal(makechar(int(this[1:],8)&0xff))\n    if not isoctal:\n     a((MARK,int(this[1:])))\n   else :\n    try :\n     this=makechar(ESCAPES[this][1])\n    except KeyError:\n     pass\n    literal(this)\n  else :\n   literal(this)\n   \n i=0\n groups=[]\n groupsappend=groups. append\n literals=[None ]*len(p)\n if isinstance(source,str):\n  encode=lambda x:x\n else :\n \n \n  encode=lambda x:x. encode('latin-1')\n for c,s in p:\n  if c is MARK:\n   groupsappend((i,s))\n   \n  else :\n   literals[i]=encode(s)\n  i=i+1\n return groups,literals\n \ndef expand_template(template,match):\n g=match. group\n sep=match. string[:0]\n groups,literals=template\n literals=literals[:]\n try :\n  for index,group in groups:\n   literals[index]=s=g(group)\n   if s is None :\n    raise error(\"unmatched group\")\n except IndexError:\n  raise error(\"invalid group reference\")\n return sep. join(literals)\n \n \n"]}